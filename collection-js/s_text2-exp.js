/*
the text part of the chemlambda g+ collection. Only those comments which have .gif files attached are here.
author: Marius Buliga
licence: CC-BY-4.0 for all text and images of this collection
last modified: 29.12.2019

*/


var collectionComments = [{"title": "10_quine_bubble_x3_short.gif",
  "description": "Dust to dust. 15 sec of life of an artificial life organism (a hybrid of 3 exemplars of a 10 bubble quine). Done in chemlambda, with quiner mist. The real life of the organism was about 4 min, here you see, as usual, a sped up screencast.<br>Follows up the post about the snowflake quine<br><a href=\"collection.html#43\" onclick=\"location.hash = 43; StartingPost();\">show</a>"}, 
{"title": "16_quine_A_L_FI_FO_duplicate_8X.gif",
  "description": "Colony of 8 16 bubble quines."}, 
{"title": "16_quine_A_L_FI_FO_duplicate_8X_var_short.gif",
  "description": "Autonomous dendrites growth."}, 
{"title": "20_20_hybridX2.gif",
  "description": "\"Everything needs to change, so everything can stay the same\". Quines are the bricks of life. Here you see one such chemlambda quine which interacts with the open environment, randomly."}, 
//{"title": "20_20_hyb_synt_experia_veryshort.gif",
//  "description": "Movie sequence. It is done entirely with the chemlambda scripts. The only editing operations were screencast, speeding it and trimming the beginning and the end.<br><br>Compare with the chemlambda demos<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/demos.html\">chemlambda demos</a><br>and click on the orange badge to go to the repository."}, 
{"title": "20_20_hyb.gif",
  "description": "How big an artificial living molecule can be? As big as you wish!<br>This is an intermediary step towards chemlambda quines with sophisticated metabolisms.<br>(see the chemlambda collection for older, visually funky posts:<br><a href=\"collection.html\">here</a> )<br><br>There is an easy procedure, which I call \"hybridization\", which allows to obtain new, bigger quines from collections of smaller ones.<br><br><br>Recall: An artificial microbe (aka chemlambda quine) is a molecule which keeps approximately its shape under random interactions with rewrite enzymes. Such a microbe has a metabolism which consists into replacing its internal atoms (nodes) with new ones, continuously.<br><br>Now, in the animation you see a 160 nodes quine! It is made of 8 copies of a 20-quine, with the bonds mixed. The idea is to take a pattern of two nodes and their bonds, the same for two quines, and redirect a pair of bonds, so that you get a new graph.<br>This is somehow like the operation of taking products of knots!<br><br>A second feature of the animation is that the metabolism is visualized here by the following trick: every atom keeps its radius unchanged for a time, and after after that it shrinks to a smaller one. In this way you can clearly see the new atoms which are incorporated into the structure of the artificial microbe.<br>How I did it:<br>- instructions here <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br>- download the gh-pages branch of the repo from this link <a href=\"https://github.com/chorasimilarity/chemlambda-gui/archive/gh-pages.zip\">zipped</a><br>- unzip it and go to the folder \"dynamic\"<br>- edit the script quiner.awk (if you need to set the parameters as described further)<br>- in the dynamic folder there is also the mol file 20_20_hybrid.mol (look inside to see what contains)<br>- be sure that in the quiner_awk you have:<br>- all wei_* set to 1<br>- cycounter\u003d50  (means 50 time steps)<br>- time_val\u003d2   (update the graph every 2ms)<br>- then write in a terminal window bash quiner.sh<br>- you will get a list of mol files, type 20_20_hybrid.mol<br>- you get 20_20_hybrid.html<br>- open it with a browser; I use safari, for a reason nobody knows (AFAIK) firefox sucks a bit, especially with such graphs with massive, repeated rewrites (if you have a solution for solving this please let me know, but AFTER you understand what the problem is, please. I suck at programming and I\u0027m an opportunistic user of anything with the condition it works. I know, I\u0027m not a programmer, but recall I might know OTHER things, so please don\u0027t look down on me. Be helpful and I\u0027ll thank you publicly!)<br>-enjoy the view!<br><br>There are other parameters in firstpart_q.txt, like the gravity, or the delay time before a node shrinks, the size of the animation window, go figure what you want and modify them as you wish!<br><br>You may wish to go to the page of other demos<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/demos.html\">chemlambda demos</a><br>or<br>you may want to see more about this project (there are lots of pages to see) at the chemlambda index<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/index.html\">link</a><br>WHOAMI<br><a href=\"http://imar.ro/~mbuliga/\">homepage</a>"}, 
{"title": "20_quine_50steps.gif",
  "description": "An artificial microbe (aka chemlambda quine) is a molecule which keeps approximately its shape under random interactions with rewrite enzymes. Such a microbe has a metabolism which consists into replacing its internal atoms (nodes) with new ones, continuously.<br>The metabolism is visualized here by the following trick: every new atom keeps its radius for 3s, after that it shrinks to a smaller one. In this way you can see how new atoms enter in the structure of the microbe, again and again, while in the same time the overall size of the microbe is approximately the same (thus the microbe does not get fatter, which means that there are atoms going away too).<br>Tools used:<br>- instructions here <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br>- the mol file 20_quine.mol<br>- all wei_* set to 1<br>- cycounter\u003d50  (means 50 time steps)<br>- time_val\u003d2   (update the graph every 2ms)<br>- there is a slight modification of the header of the html file which is outputted by the script, namely in the file firstpart.txt (which is the header) just before \"node.exit().remove();\" add \" .transition() .delay(3000) .attr(\"r\", 2); \" for the animation which shrinks the nodes.<br>For a live demo of the 20_quine, which is also less quicker (so that it works in any browser) see<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/sparks.html\">sparks.html</a>"}, 
{"title": "20_quine_alafoeafoe_hyb_breathing.gif",
  "description": "Breathing. As in the last animation, the alternate availability of rewriting enzymes makes this quine to grow, then to shrink, then to grow again..."}, 
{"title": "20_quine_alafoeafoe_hyb.gif",
  "description": "One or many organisms? With 1494 edges and 1332 nodes initially, this is a big quine made of 3 exemplars of 20_quine_alafoeafoe.mol, the quine which appears in the post<br><br>Complex lifeforms<br><a href=\"collection.html#9\" onclick=\"location.hash = 9; StartingPost();\">show</a><br><br>The visualization is made for testing the limits of the browser, the computation itself (done by quiner.sh, which produces the html file which runs in the browser) is easy.<br><br>I used 20_quine_alafoeafoe_hyb.mol and quiner.sh, after I changed the parameters in quiner_awk like this: metabo\u003d100, shiftmetabo\u003d100, which means that with the period of 100 big nodes, the colour of the following 100 big nodes and their ports (i.e. approx every 300-400 new nodes) switches from the normal one to black and then back to normal.<br>This shows visually the result of the metabolism of the organism, because you can see which and where new nodes enter in (or get out from) the graph.<br><br>Compare with the post 27 microbes<br><a href=\"collection.html#20\" onclick=\"location.hash = 20; StartingPost();\">show</a>"}, 
{"title": "20_quine_alafoeafoe_hybX3_short.gif",
  "description": "Stringy molecules interacting, again pushing too much my computer and then limited by the communication medium. Makes me wonder, though, that\u0027s almost too pure: random walking in a big group of permutations (pairs of permutations, these are colored ribbon graphs) along some directions defined by the rewrites... Could too pure, coupled with the right foundations (no global semantics, async, local) be almost enough for such a range of complex phenomena? Anyway, in this system surprises are everywhere, waiting to be discovered."}, 
{"title": "20_quine_alafoeafoe.gif",
  "description": "Complex lifeforms. Here is continued the exploration of fractal like replacements of patterns by their complements, in a bigger graph.<br><br>This is a 20-quine which has 4 patterns erased (AL, AFOE, AFOE, LFOE) and replaced by their complements in a 20-quine). It is therefore the result of a fractal like operation.<br>What happens is that the metabolism is much more complex, probably because the replacements have their own metabolism which is self-regulated by the interactions between these and the remaining nodes of the original quine.<br>What you see is a random run (used quiner.sh with 120 steps) which represents an unique evolution, consisting of thousands of random chemical reactions suffered by this molecular lifeform. Still, with all this randomness, without any external control or laboratory external sequence of operations, the lifeform survives and exhibits complex behaviour.<br><br>Live at <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/20_quine_alafoeafoe.html\">20_quine_alafoeafoe.html</a><br>(attention, works in safari for sure, almost sure in chromium, have not installed chrome, I guess that firefox can\u0027t handle it from past experiences)<br><br>Video <a href=\"https://youtu.be/lMH8I-woAiU\">youtube</a> (5min, the animation shows the first 15s)<br><br>Validation means: the mol file used is<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/20_quine_alafoeafoe.mol\">20_quine_alafoeafoe.mol</a><br>with the script quiner.sh (cycounter\u003d120), see the instructions here<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "20_quine_alafoe.gif",
  "description": "Towards fractal patterns in quines. In the post The case of the pattern which is not there<br><a href=\"collection.html#14\" onclick=\"location.hash = 14; StartingPost();\">show</a><br>I replaced a 2 nodes pattern (A-L, used for the BETA reduction) by its complement in a 20-quine.<br>This gave a bigger quine made of parts where the particular pattern was deleted and replaced by another bigger one.<br><br>Here I replace two patterns by complementary ones in the 20-quine. One pattern is the A-L and the other is a A-FOE. The difference between these patterns is that while A-L is used in the BETA move which decreases nodes, A-FOE is used in a dist move which increases nodes.<br>So in a 20-quine I delete an A-L pattern and a A-FOE pattern, giving a 16 nodes molecule. Each pattern is replaces by a 18-nodes molecule which is obtained from a 20-quine with the patterns A-L and A-FOE deleted, respectively.<br>The interesting part is in the gluing: while the part left free by the deletion of the A-L pattern is glued to the complementary one (18 nodes) via 4 Arrow elements, the part left free after deletion of the A-FOE pattern is glued to the complementary one via two patterns of 4 nodes each.<br>The explanation is that for gluing are used, each time, pattern which appear in the moves (BETA or dist) after the respective moves are done.<br>So we have, initially 16+18+18+8\u003d 60 nodes (Arrow not counted) which stabilizes into a 18+18+18\u003d54 nodes quine.<br>Supplementary, the metabolism is visualized by letting only nodes with age less than 7s to have big radii, any older node shrinks to a dot.<br><br>This of course leads to the idea that we may replace all patterns by bigger ones, then again, then again...<br><br>The mol file used is 20_quine_alafoe.mol<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/20_quine_alafoe.mol\">20_quine_alafoe.mol</a><br>from the chemlambda repository.<br>Instructions to use<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "20_quine_cut_synt_hyb_red_short.gif",
  "description": "Action! These animated gifs do not compare with the big screen movie version, but still, there is action.<br>This is another learning by doing example of using the scripts. The near goal is the artificial cell movie, continued by the real game (which strongly depends on the rewriting better scripts and waiting for better guis to appear)."}, 
//{"title": "20_quine_exp.gif",
//  "description": "Evolution of a 20-quine, with a visualization trick.<br>The inner bonds appear as thin, long segments, the main atoms appear in a circle, far from the center of the image, the outer bonds appear as thick short segments in a circle closer to the center of the image. All nodes shrink to a smaller size after a bit, in order to visualize the metabolism of the quine.<br><br>Live at:<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/20_quine_exp.html\">20_quine_exp.html</a>"}, 
{"title": "20_quine_stringalafoe.gif",
  "description": "What is time for a quine? Attention, look for the two red Y-shaped molecules!<br><br>The deterministic evolution of quines is also interesting. That\u0027s how I learned several things.<br><br>First is that here is really better to define chemlambda quines as molecules in the artificial chemistry chemlambda with the property that the evolution under deterministic conditions is periodic.<br><br>For example, even if the 28-quine (the one which comes from the \"walker\" molecule which is inside the representation of the predecessor term from lambda calculus) is a quine with period 1, the 20-quine has period 4.<br><br>The shortest quine, the 9-quine, has also period 1.<br><br>The 20-quine, as well as the 16 bubble quine have been found by searching for repeating patterns in a database for molecules evolution.<br>That is why I have not noticed the period.<br><br><br>Secondly, as I wrote, the 20-quine has a period of 4 cycles, which can be checked by running quiner.sh with wei_...\u003d0, and with 20_quine.mol as input.<br><br>Video at <a href=\"https://youtu.be/LdTRPXd1ILo\">youtube</a><br><br>The result is shown in the first part of the video, where you can discern the repetition of patterns every 4 \"pulsations\". This animation has 30 cycles, or time steps, so set cycounter\u003d30 in the quiner.awk. It is the deterministic evolution of the 20-quine.<br><br>In the second part of the video you see a string of 3 crippled 20-quines which is assembled by replacing the A-L pattern by its complement in the 20-quine, then by replacing the A-FOE pattern from the complement just introduced, by its complement. Still the deterministic running shows that after few steps it stabilizes into a quine with 4 cycles period, just like the original 20-quine.<br><br>The animated gif shows a period of this string of 3 crippled quines. Watch carefully for familiar patterns, like the two red Y which appear, to notice that.<br><br>Now let\u0027s see what does it mean.<br><br>The deterministic evolution is when we allow all possible rewrites to be applied at once, as if the molecule is surrounded by all (invisible) rewriting enzymes at once.<br><br>The fact that for quines the evolution is periodic make us think that the periodicity is somehow externally imposed by the synchronization of the rewrites.<br><br>It would be so in case of the deterministic evolution, but in the case of random evolution the synchronization is lost, i.e. this becomes an asynchronous graph rewrite automaton (as real chemistry is, don\u0027t forget).<br><br>The simple fact that the organism, the quine, continues to survive in the random evolution (actually gets an interesting life, with ups and downs, and sometimes it may even die, like the 9-quine) shows that there is something which replaces the synchronization of rewrites.<br><br>Indeed, by definition of a quine, the deterministic evolution never stops (because it\u0027s periodic), so we may conceive the narrative that some rewrites are used \"by the quine\" in order to build patterns for future rewrites. Therefore the synchronization (i.e. all rewrites at once) is beneficial for the quine because it is a way to be sure it can rebuild itself.<br><br>This kind of thinking is somehow familiar, as an example, in explanations about global synchronization of the brain waves, which explain this or that phenomenon. I don\u0027t believe in them because brains don\u0027t have other supervisor brains with chronometers embedded.<br><br>The random life of quines shows that structure (chemical structure in this case) replaces timing.<br><br>By the same definition of a quine, it means that all the patterns which appear after a rewrite are already present in a previous version of the quine.<br><br>Validation means: I used the mol file 20_quine_stringalafoe.mol and the quiner.sh from the chemlambda repository. I set in quiner.awk all parameters wei_...\u003d0 (to have a deterministic evolution) and cycounter\u003d30.<br>Instructions about how to use the repository<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>Or just look directly at the demos already available by starting from the<br>chemlambda index<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/index.html\">link</a><br>where you may notice the little blue strings of text which can lead you towards other pages with more detailed info."}, 
{"title": "2_20quine_box.gif",
  "description": "Command for cytokinesis A big artificial chemlambda molecule made to illustrate that it is possible to embed commands for splitting into two identical organisms (cytokinesis <a href=\"https://en.wikipedia.org/wiki/Cytokinesis\">wikipedia</a>)<br><br>The molecule you see at the start of the animation is made of two 20-quines ( 20_quine.mol ), which appear as two \"wings\" and the adaptation of the molecule ISZERO 2 (first part of boxempty.mol).<br><br>The mol file, available at the chemlambda repository, is 2_20quine_box.mol. Animation made with quiner.sh.<br>Instructions at <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>What happens: the two quines are kept together, for a while, and in the same time ISZERO 2 part transforms into the pattern \"\u003d\" of bonds (and releases a \"bubble\" made of 3 Arrow nodes, in this random run). Then the two quines aggregate splits into two smaller molecules (which are 20-quines in different states).<br><br>You find more about chemlambda quines and other animations (like boolean computations with crossings) in the microblogging chemlambda collection<br><a href=\"collection.html\">here</a><br><br>As concerns chemlambda quines only, a brief informative post at my open notebook can be read at once:<br>Artificial life, standard computation tests and validation<br><a href=\"https://chorasimilarity.wordpress.com/2015/05/17/artificial-life-standard-computation-tests-and-validation/\">post</a><br><br>Booleans in chemlambda and crossing collected in<br>Crossings as pairs of molecular bonds; boolean computations in chemlambda<br><a href=\"https://chorasimilarity.wordpress.com/2015/06/09/crossings-as-pairs-of-molecular-bonds-boolean-computations-in-chemlambda/\">post</a>"}, 
{"title": "2_20quine_empty.gif",
  "description": "The case of the pattern which is not there .<br>This is a way to build quines from other quines which is different than hybridization [1].<br><br>In this animation I took two 20-quines (20_quine.mol) and a boolean wire (boolewire.mol).<br><br>Then I picked the same pattern (for the BETA, aka A-L rewrite) of two nodes, in each quine, and I erased it.<br><br>Then I used Arrow nodes to glue the two crippled quines by the boolean wire [2].<br><br>Notice that the pattern A-L misses from both quines, but due to the fact that they are quines, the pattern is produced by the remaining part of a quine and teleported by the boolean wire to the other quine.<br><br>This way we get a 38-quine because 38\u003d(20-2)+(20-2)+2.<br><br>Validation means: Made with 2_20quine_empty.mol and quiner.sh from the chemlambda repository. Instructions to use<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br> [1] hybridization explained in the post How big an artificial living molecule can be?<br><a href=\"collection.html#4\" onclick=\"location.hash = 4; StartingPost();\">show</a><br><br>[2] Boolean wire<br><a href=\"collection.html#81\" onclick=\"location.hash = 81; StartingPost();\">show</a>"}, 
{"title": "2_6_exp_2_later.gif",
  "description": "The Seed, later. Continuation of the post \"CryptNet\u0027s true desire is the Seed\" [1]. If you look in the chemlambda repo [2], there is a folder \"test\", containing a variant of the (deterministic) program which spits out molecules (mol files) instead of js animations. This can be used for quickly advance to later states of the evolving molecule.<br><br>The original use of the test folder is for comparisons of my version with chemlambda-hask [3], i.e a Haskell version done by synergistics.<br><br>[1] CryptNet\u0027s true desire is the Seed<br><a href=\"collection.html#16\" onclick=\"location.hash = 16; StartingPost();\">show</a><br><br>[2] Chemlambda repository (the active branch)<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[3] Chemlambda-hask (by synergistics)<br><a href=\"https://github.com/synergistics/chemlambda-hask\">link</a>"}, 
{"title": "2_6_exp_2.gif",
  "description": "\"CryptNet's true desire is the Seed\" a technology that, in their diabolical scheme, will one day supplant the Feed, upon which our society and many others are founded. Protocol, to us, has brought prosperity and peace—to CryptNet, however, it is a contemptible system of oppression. They believe that information has an almost mystical power of free flow and self-replication, as water seeks its own level or sparks fly upward— and lacking any moral code, they confuse inevitability with Right. It is their view that one day, instead of Feeds terminating in matter compilers, we will have Seeds that, sown on the earth, will sprout up into houses, hamburgers, spaceships, and books—that the Seed will develop inevitably from the Feed, and that upon it will be founded a more highly evolved society.\" [Neal Stephenson, The Diamond Age]<br><br>The image is a part of the computation of a double exponential."}, 
{"title": "2_exp_6.gif",
  "description": "Packed fractal In the series of chemlambda fractals (see for example [1]) I used several times molecules inspired from the lambda terms involving exponentiation. This one is related to 2^6, random rewrites algorithm, I tried it because powers of 2 should give the most packed fractals. It does!<br><br>[1] Fractal explosion<br><a href=\"collection.html#31\" onclick=\"location.hash = 31; StartingPost();\">show</a>"}, 
{"title": "2species.gif",
  "description": "Two species remain in this rerun of the pool of 27 microbes (i.e quines) where the availability of rewriting enzymes varies periodically, from those who favour nodes destruction to those who promote growth. Compare with the shorter time animation from post [1], also as a more detail youtube video [2].<br><br>[1] 27 microbes g+ post<br><a href=\"collection.html#20\" onclick=\"location.hash = 20; StartingPost();\">show</a><br><br>[2] 27 microbes the video<br><a href=\"https://youtu.be/UWR-mi0OTsQ\">youtube</a>"}, 
{"title": "3_20_quine_stringalafoe_ring.gif",
  "description": "Learning to use the scripts for obtaining more realism from motion. Once more, everything is a screencast."}, 
//{"title": "3_27_quine_huge_short.gif",
//  "description": "1000X this makes a microbiome OS. This is twice the last dish of chemlambda microbes. Can you see it?<br><br>Done with 3_27_quine_huge.mol and quiner.sh from the chemlambda repository."}, 
{"title": "3_27_quine.gif",
  "description": "27 microbes. This is a glimpse of the life of a community of 27 microbes (aka chemlambda quines). Initially the graph has 1278 nodes (atoms) and 1422 edges (bonds). There are hundreds of atoms refreshed and bonds made and broken at once. The animation is based on a screencast which can be seen at<br><a href=\"https://youtu.be/UWR-mi0OTsQ\">youtube</a><br><br>The purpose is to show the difference between the computation and the visualization of the result. The computation has been done with quiner.sh and 3_27_quine.mol from the repository, the visualisation is done with safari, the browser which up to now has proved to be the most flexible as concerns these programs of mine.<br><br>The computation was a piece of cake, the visualization works but is kind of slow, so the screencast is made at 8X speed.<br><br>At the demos page you can find the ancestor of this, namely<br><br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/3_9_quine.html\">3_9_quine.html</a><br><br>and you can explore more and do your stuff, or validate the background of these post, by going to the README of the repo<br><br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "3_3_FI_FO_A_L_hyb.gif",
  "description": "Conservative quine. A chemlambda quine is a molecule which has a periodic evolution in the deterministic reduction algorithm (where, recall, the node-increasing rewrites have priority over the node-decreasing rewrites, in case of conflict). The most simple case is the one where the quine evolution has period 1. For such quines, of course that the number of nodes is conserved.<br><br>What about quines with long period, but with conserved number of nodes?<br><br>Let\u0027s organize a bit things. Say a quine has node variation at most K if during the evolution of the quine (deterministic, etc) the number of nodes is in the interval [N-K, N+K] for some number N.<br><br>A L conservative quine is one which is K conservative, with period T, such that K/T is less than or equal than L.<br><br>The game is to produce L conservative quines with arbitrarily small L.<br><br>In this animation you can see a molecule which grows into a (bubble) quine with a bit T and a small K (bubble, i.e Arrow nodes do not count), in the random algorithm. You can see that the K is small by looking at the ring of bubbles which varies only slightly. That is because all the nodes are attracted towards the center of the rectangle and they are all charged, therefore the bubbles, which are small and disconnected from the main graph, are attracted towards the center by their own weight and repelled by the sum of the charges of the main graph (i.e. the no of nodes).<br><br>Also, you can see that T has to be big, because the network of edges varies wildly.<br><br>As usual, only a small piece of the whole animation fits into this gif."}, 
{"title": "3_exp_3_hyb.gif",
  "description": "Divide or not divide. This is an example of a molecule (3_exp_3_hyb.mol from the library of molecules [1]) which may divide or not, depending on the resolution of the conflict between two overlapping rewrites, AL and AFO. See the list of rewrites in the molecular computer article [2].<br><br>Indeed, the list of chemlambda rewrites is not free of conflicts. A conflict between rewrites appears when there are overlapping patterns for two different rewrites, such that the resulting molecule depends on the choice of the rewrite among the two in conflict.<br><br>There is only one important conflict, the one involving AL (i.e. the beta rewrite dear to lambda calculus) and the AFO (or AFOE). For molecules corresponding to lambda terms, this conflict extinguishes due to the special connectivity of such molecules, but for other molecules, such as the one presented here, the conflict resolution may lead to the appearance of a pair FI-FOE which is a trigger for molecule division.<br><br>This animation contains two different runs of the random algorithm for the same molecule. I used bash quiner_shuffle.sh and the molecule 3_exp_3_hyb.mol. As the name of the molecule tells, is a relative of the molecule for 3^3, one of those discussed in preceding animations obtained with the deterministic algorithm. All I did, in order to obtain this new molecule, was the following:<br>- I added a FO node FO out out1 out2<br>- and I changed the wirings for the first lambdas of the pair of numbers 3 in Church encoding (i.e. permuted the pair of port variables fnum and afnum). If we neglect the FO node, this molecule would correspond to an incorrect lambda term. To explain this, think about the 3 in church encoding as a term Lx.A[x], so 3^3 has the form (Lx.A[x])(Ly.A[y]). THe mentioned permutation would correspond to the incorrect lambda term<br>(Lx.A[y])(Ly.A[x]).<br><br><br><br>[1] library of chemlambda molecules<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[2] Molecular computers<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/molecular.html\">link</a>, <a href=\"https://arxiv.org/abs/1811.04960\">arXiv:1811.04960</a>"}, 
{"title": "3_sheet_1_13_quine.gif",
  "description": "Structure from symmetry. Initially this is a molecule which is made by 3 identical pieces, assembled so that there is an overall cyclic symmetry 1-2-3-1. But under random conditions, as you see, it evolves into having 3 specialized regions.<br><br>Now, imagine that\u0027s a kind of a seed. Or that you can build anything this way, starting from a kit containing a canned soup of simple (but well designed) identical pieces and a vial of well chosen enzymes."}, 
{"title": "3_tape_long_5346_det.gif",
  "description": "Deterministic synthesis from a tape, compare with the random version [1].<br><br>[1] Synthesis from a tape<br>[unavailable]"}, 
{"title": "3_tape_long_5364_d.gif",
  "description": "Deterministic duplication (2) compare with the random version [1]. See also the video [2] for another comparison.<br><br><br>[1] Is this duplication?<br><a href=\"collection.html#26\" onclick=\"location.hash = 26; StartingPost();\">show</a><br><br>[2] Deterministic vs random on Vimeo<br><a href=\"https://vimeo.com/139024564\">link</a>"}, 
{"title": "3_tape_long_5364.gif",
  "description": "Is this duplication? I used a very small modification of the triple loop from the last simulation about metabolism and replication [1]. This time the computation stops, but the result shows a rich structure.<br><br>[1] Synthesis from a tape<br>[unavailable]"}, 
{"title": "3_tape_long_5364_X2_s.gif",
  "description": "Deterministic (pseudo)duplication in 17 steps, done for a hybrid [2] of two copies of the molecule from [1], done with moving_random_metabo.sh from the github repository [3]. If you look in the sta.txt (the stats produced by the script) then you\u0027ll see that for the most part of the computation there is a period 2 cycle of rewrites.<br><br>[1] Is this duplication?<br><a href=\"collection.html#26\" onclick=\"location.hash = 26; StartingPost();\">show</a><br><br>[2] molecule used<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/3_tape_long_5364_X2.mol\">3_tape_long_5364_X2.mol</a><br><br>[3] <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "3_tapes_short.gif",
  "description": "Bubbles creatures, an exercise with tapes actually."}, 
{"title": "3X_28_20_quine.gif",
  "description": "4 pieces colony is actually obtained from 3 copies of a quine, with only 3 bonds switched. I suspect that\u0027s actually one quine which is not connected as a graph. It would not be very surprising, because already there is the 16 bubble quine which is not connected, but that\u0027s a \"bubble\" quine, i.e it produces closed strings of Arrow elements (bubbles)."}, 
{"title": "4_13_quine_tree.gif",
  "description": "The maker of starmakers In the post [1] you can see a star maker molecule. In this post I made a molecule which maker 3 starmakers :)<br><br>If you use safari as the browser, then you may enjoy the real js animation at the address<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>It might work with chrome/chromium as well, but it surely blocks in firefox. I don\u0027t know why, maybe somebody could explain it to me!<br><br><br>[1] <a href=\"collection.html#120\" onclick=\"location.hash = 120; StartingPost();\">show</a>"}, 
{"title": "4_exp_4_foe.gif",
  "description": "Fractal explosion. Like in the last post [1], I used the test scripts from the chemlambda repository in order to produce a simultaneous creation and duplication of the fractal like molecule representing 4^4. You can make the same by repeating the procedure described in [1], but for the mol file 4_exp_4_foe.mol. If you compare it with it\u0027s brother 4_exp_4.mol, then you\u0027ll see that it\u0027s shorter :) How come?<br><br>These mol files are part of the chemlambda mol files library [2] which has hundreds of molecules to play with.<br><br>Incidentally, I\u0027ve opened a project [3] at ResearchGate about molecular computers, if interested to connect through that walled garden then please do it.<br><br>[1] Fractal out of the box<br>[unavailable]<br><br>[2] Library of chemlambda molecules<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[3] Molecular computers, graph rewrite systems and decentralized computing<br><a href=\"https://www.researchgate.net/project/Molecular-computers-graph-rewrite-systems-and-decentralized-computing\">link</a>"}, 
{"title": "4neurons.gif",
  "description": "Snapshots sequences may give more dynamical short views than simple sped-up ones."}, 
{"title": "4walkers_mitotic_spindle.gif",
  "description": "Mitotic spindle. By an adaptation of the dodecahedral walker molecule [1] we obtain a chemlambda version of a mitotic spindle creation. For comparison, there is a sequence from a simulation of the yeast mitotic spindle taken from [2].<br><br>[1] Dodecahedral walker<br><a href=\"collection.html#98\" onclick=\"location.hash = 98; StartingPost();\">show</a><br><br>[2] Yeast mitotic spindle model<br><a href=\"https://www.youtube.com/watch?v\u003d4E0Vh4kvyFQ\">youtube</a>"}, 
{"title": "5_13_quine_ring_double_hyb.gif",
  "description": "Star buds (hybridisation is a derivative part II). I used quiner_node.sh and the starmaker molecule with actor colors from [1], which I hybridized with a starmaker version where the 5 exemplars of the 13 quine which makes it do not cooperate. The hybridisation was done along the same lines as in the post [2]. The effect is the following:<br><br>- the two hybridized molecules evolve, eventually, independently, as it happens with the molecules from [2]<br>- therefore the non-cooperating version of the starmaker splits rather quickly into the 5 quines, each of them monocolor (mind that these are bubble quines, hence the bubbles floating around)<br>- in the same time the starmaker still does it\u0027s job, to produce collaboratively 5-colored stars, but in a more involved way, looking like flower buds which are eventually released into the air.<br><br>Remark the good behaviour of the colored rewrites, which by completely local means keep the actor colors where they should be, thus allowing us to recognize the molecule parts.<br><br>[1] Starmaker factory<br><a href=\"collection.html#35\" onclick=\"location.hash = 35; StartingPost();\">show</a><br><br>[2] Hybridization is a derivative<br><a href=\"collection.html#68\" onclick=\"location.hash = 68; StartingPost();\">show</a>"}, 
{"title": "5_13_quine_ring_mola.gif",
  "description": "Starmaker factory. With the help of actors colours and colored rewrites, we can see how the stars are made by the starmaker molecule. For older simulations of the starmaker see [1].<br><br>The starmaker molecule is a hybridization of 5 exemplars of a 13 quine. The mola file (colored mol file) used is [2], where each 13 quine received it\u0027s colour, initially. Now you can see that each star is made by assembling pieces of each of the 5 actors.<br><br>[1] Starmaker, deterministic version<br>[unavailable]<br><br>[2] claudia_starmaker with actors<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mola/5_13_quine_ring.mola\">5_13_quine_ring.mola</a>"}, 
{"title": "5_13_quine_ring_var.gif",
  "description": "Non-cooperating starmaker. In [1] I wrote that I used a hybridization between the starmaker and a non-cooperating version of it. Here is it!<br><br>[1] Star buds (hybridization is a derivative II)<br><a href=\"collection.html#34\" onclick=\"location.hash = 34; StartingPost();\">show</a>"}, 
{"title": "5_13_ring_tape_long_5364.gif",
  "description": "Nanomachine factory. There\u0027s a funny exploratory side of chemlambda, when I just hybridize two molecules to see if the result has the qualities of both parents. Here I took the starmaker [1] and the successful tape replicant [2] and, what do you think? I got a nanomachine builder.<br><br>The template of the machine appears in the upper part of the animation. There is a nice initial pentagon of red nodes too, which appears also in the first stages of [1], like a clearing salvo before the good thing starts to come through the pipe.<br><br>[1] The starmaker<br><a href=\"collection.html#120\" onclick=\"location.hash = 120; StartingPost();\">show</a><br><br>[2] Synthetic replication<br><a href=\"collection.html#230\" onclick=\"location.hash = 230; StartingPost();\">show</a>"}, 
{"title": "5_13_ring_tape_long_5364_X24.gif",
  "description": "Molecular factories based on [1]. The animations from this collection are done by screencasting, then by simple modification of the video speed. Nothing else. This animation is an exception, a very simple one though. I used the nanomachine factory simulation [1] video in older to make this pool of molecular factories. At this resolution the image is too black so a sepia filter is applied.<br><br>For the project [2] of making an artificial cell movie/game, it is relevant to have an idea how the viewer bears with the visual complexity of having many molecules on screen.<br><br>[1] Nanomachine factory<br><a href=\"collection.html#37\" onclick=\"location.hash = 37; StartingPost();\">show</a><br><br>[2] A trailer for a movie<br><a href=\"collection.html#101\" onclick=\"location.hash = 101; StartingPost();\">show</a>"}, 
{"title": "5_16_bubble_quine_double_double_hyb_hyb_actors_sho.gif",
  "description": "Quines are not actors. One more animation which shows that."}, 
{"title": "5_actors.gif",
  "description": "Five actors. First appearance of actors in the chemlambda demos. You can see it live here [1]. Do not use Firefox because it won\u0027t resist. I guess... Use safari or chrome/chromium.<br>[1] <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/3_20_quine_stringalafoe_ring.html\">3_20_quine_stringalafoe_ring.html</a>"}, 
{"title": "6_13_quine_ring_ring.gif",
  "description": "Centrosome. \"At the mark X is the treasure in this Island\" says the Pirate. What he really means is reduce<br><br>(Map of Island)(Treasure)<br><br>where Map of Island \u003d \\x.Island, or, equivalently, the Island map with an X marking the treasure\u0027s place.<br><br>Trivial! Only that the Pirate does not think in these terms, but instead in spacial ones, with maps and territories.<br><br>Funny that \"The map is not the territory\" simply means that one should not use eta reduction :)"}, 
{"title": "8_bricks_5_13_quine_hyb.gif",
  "description": "Molecular embroidery done by the starmaker molecule (upper part of the figure) on the 8_bricks quine."}, 
{"title": "8_bricks_short_opt.gif",
  "description": "The snowflake quine. This is an example of a quine which is very symmetric initially, then it evolves into an asymmetrical shape, due to randomness. Eventually it dies, retrieving the symmetry: a snowflake."}, 
{"title": "9_9_hyb.gif",
  "description": "When biological immortality is possible in Nature, why is it so rare, especially for complex organisms?<br>In a previous post I wrote about an artificial life form which simulates biological immortality.<br><a href=\"collection.html#127\" onclick=\"location.hash = 127; StartingPost();\">show</a><br><br>It is explained there that in the artificial chemistry world called \"chemlambda\" there are molecules, microbes or bugs, call them as you wish, which have the property that when they suffer random chemical reactions with invisible enzymes, they arrive to preserve approximately their shape. They are called chemlambda quines (where \"quine\" comes of course from the computing realm).<br><br>A chemlambda quine has the property that when it suffers all the possible chemical reactions at once then after it is isomorphic (identical as a graph) with it\u0027s state before the reactions.<br><br>When it is put in a random medium, such an artificial bug gets a life of its own, depending on the particular cascades of reactions it suffers, but because it is a quine, it approximately arrives to keep its shape.<br><br>Not all the time, there is of course, in the realm of possibilities, the one (or many) path(s) to destruction. We say that a quine dies if it arrives in a state when no possible further reactions are possible.<br><br>A quine is biological immortal in the sense that the probability of arriving in a death state does not depend on the age of the organism.<br><br>In the previous post I have shown you an example of such a quine which, under stress (lack of enough available enzymes), it regresses to an egg-like state, from where, when opportunity arrives, it grows again and again.<br><br>Let\u0027s pass further. We can uses quines as bricks for making bigger organisms. In the post<br><a href=\"collection.html#4\" onclick=\"location.hash = 4; StartingPost();\">show</a><br>is given an example of a big, 160-nodes quine made by a procedure called \"hybridization\" from 8 exemplars of a 20-quine.<br><br>Hybridization means that if you have two molecules (chemlambda graphs) which have somewhere two identical subgraphs (patterns), then you can rewire the bonds from these two patterns by taking two bonds, one from each pattern, and switching the ends, so that now the patterns are mixed.<br><br>It is not clear if the result is still a chemlambda quine (I think is not). But it is a sort of quine anyways, in the larger sense that under a deterministical application of all possible chemical reactions available, after a finite number of steps the graph returns to the initial state.<br><br>What is funny is that such an artificial organism, even if made by biologically immortal bricks, it is no longer immortal itself: the probability of death depends on the age, specifically it increases with the age.<br><br>Indeed, let\u0027s take a particularly fragile quine, the 9-quine. This is the smallest quine, it is first mentioned in my open notebook, in the post where chemlambda quines are described for the first time (way before I wrote the scripts for visualisations)<br><a href=\"https://chorasimilarity.wordpress.com/2014/09/01/quines-in-chemlambda/\">post</a><br><br>It dies fast, in the sense that the probability of death is big enough that in the runs of the chemlambda scripts you see it happening soon, most of the times.<br>(Another quine which dies fast is used in this demo of a neuron like molecule<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/neuron.html\">neuron.html</a><br>but that is for another time to explain the details and relations with real neurons.)<br><br>So, In the animation you see a hybrid of 8 exemplars of a 9-quine. It is a particular life which I have chosen for its extreme brevity, by running again and again the scripts until I found it, screen casted it, then transformed it into an animated gif.<br><br>What happens is that when one of the exemplars in the hybrid dies, then globally it becomes another quine, which has higher global probability of death.<br><br>That is why this is an example of an organism where, if you want, even its metabolic paths don\u0027t have an expiration time, it still shows senescence via the random death of one of its immortal bricks, until the probability of global death becomes a certitude.<br><br>This thread of posts can be seen at once in the chemlambda collection<br><a href=\"collection.html\">here</a><br><br>If you want to play with the animations yourself then go to the github repository and read the instructions<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>WHOAMI<br><a href=\"http://imar.ro/~mbuliga/\">homepage</a>"}, 
{"title": "ackack_actors.gif",
  "description": "Two Ackermann functions, three actors. Now that the most simple version of chemlambda is visibly working well, why not passing further, towards chemical actors? Actors, like in the Actor Model, are nothing but decorations (as anything semantic) which change according to local interactions, of the kind described for graphic lambda calculus in the article <a href=\"https://arxiv.org/abs/1312.4333\">arXiv:1312.4333</a> .<br><br>Imagine that each color tells you which actor has that node.<br><br>Now, problem: the green and the yellow actor have two different pairs of values and they both want to compute the Ackermann function for that value. But the body of the Ackermann function is the property of the red actor.<br><br>In the animation you see the starting of this, how should I call it? Negociation? Discussion? Process? Definitely not process, discussion is better. I know even better: we see a thing, because things (or \"res\" in Latin) are discussions whose evidence are objects.<br><br>(Btw, would be nice to talk without leaving a trail of evidence, but of course that this is impossible in a system designed from the ideology that reality is made of objects, i.e. made of evidence, instead of things. What evidence? Names, identities, messages, encrypted or not, but anyways sent by the sender to the receiver, by a wire which may or may not have a man in the middle, but it has for sure the sender and the receiver working on corrupted machines.)<br><br>How is this done: look in the chemlambda repository. There is now a file ackack.mola which is like a mol file but each node has now a new argument, the last one, which tells which actor has the node. The actor is a number, arbitrarily chosen from 0 to 6, because that\u0027s how many colours appeared in the visualizations until now.<br><br>The script used is quiner_node.sh, which calls an awk script, you\u0027ll see it if you look inside.<br><br>The rewrites are now augmented by adding the color rewrites.<br><br>That is all (for the moment). Nothing complicated, if you look from the right point of view."}, 
{"title": "ackerman_2_hhmi_ackermann_mny.gif",
  "description": "Artificial, real, artificial complexity. It\u0027s good to compare with the goal. The middle sequence is from the Movie 5, Li et. al., \"Extended Resolution Structured Illumination Imaging of Endocytic and Cytoskeletal Dynamics,\"  Science. See the movie here<br><a href=\"https://vimeo.com/136537187\">vimeo</a>"}, 
{"title": "ackermann_2_2_4runs.gif",
  "description": "4 ackermann runs in parallel One of my favorite molecules is the ackermann_2_2.mol. Here you see 4 random runs in parallel.<br>It\u0027s a small molecule, perfectly feasible for doing the first real experimental run of a RNA computing of a recursive but not primitive recursive function.<br>As easy, ackermann_4_4 could be tried. The result is such a huge Church number (molecule) that it\u0027s growth in a solution would be limited only by the \"rewrite enzymes\" available. It won\u0027t be grey goo by the Ackermann function, because of that, however it\u0027s funny that it would be a sort of a grey goo scenario which does not involve replication."}, 
{"title": "ackermann_2_2_fo8_space_short.gif",
  "description": "Large scale structure of a piece of Ackermann goo kind of looks like a small scale version and I don\u0027t know why.<br><br>My first guess is that\u0027s because the simulation was not very much advanced in time, so the initial stage of a tree-like structure (almost) was still present at larger scales. (Why tree like structure? Is simple: the molecule is based on a lambda term for the Ackermann function and lambda terms tend to look like trees with baggy leaves, especially when they are built in the \"functional\" way from composing simple parts. I suspect that most human-made programs look visually like this, because of the human programmer bias for such structures.)<br><br>The goo develops long strings carrying small bags later, as seen in previous simulations. But I just wanted to see how the strings pack at larger scale.<br><br><br>How I did this? I fiddled with the physics parameters so that the nodes which are more connected clump as much as possible together, while different clumps still can repel one another enough. I also made the nodes bigger and transparent so that the clumps look more material by the superposition of many transparent close disks. The simulation was filmed, sped and passed several times through filters for blurring, enhancing saturation and simplifying colors. Starting from a film of about 1.5 GB, the end gif was around 30 MB, which was still not enough so I just show you a small piece of it, of about 3.5 MB. But figure how the film looks :) Done on a regular laptop, with no special visual programs to use.<br><br>There are severe limits of these very short visual snippets. They are still informative at this stage of the project, if you bear with me until building the next stage.<br><br>Of course that there should be used code tools for exploring large scale structures in such graphs, which bring us back to semantics. You go global, you need semantics :)"}, 
{"title": "ackermann_2_2_space_take2.gif",
  "description": "Why it does not work. In the previous post How it works [1] the visualization used by that simulation shows a big molecule interacting with smaller ones. This should not work in reality like this, there is a missing piece, I\u0027m going to explain this now, by using one of the workhorses in chemlambda, the Ackermann function molecule.<br><br>It all comes from the treatment of the rewrite enzymes in the model. Recall that the chemical reactions in chemlambda have the following form:<br><br>(1)    (Left Pattern) + Enzyme - - \u003e (Right Pattern) + Enzyme + Trash<br><br>OK, so what if instead of using an Enzyme/rewrite type we would try an easier version? Suppose that there is a Cut Enzyme which perhaps recognizes all Left Patterns and cuts them. Then there are Bind Enzymes which use what\u0027s available, randomly around) to bind back the molecule so that the (Right Pattern) appears. That means the chemical reaction (1) should be replaced by:<br><br>(1\u0027)  (Left Pattern) + (Cut) - - \u003e (Cut) + Other molecules<br><br>(1\") Other molecules + (Bind) - - \u003e (Right Pattern) + (Bind) + Trash<br><br>In this way, it does not matter if the Right pattern is built exactly from what results after cutting the Left pattern, provided there is a (chemical) match.<br><br>One of the most important conditions in chemlambda is locality, which here means that it should be possible to implement the reaction (1\") locally, meaning that there should be an absolute bound on the size of the (Other molecules) patterns which makes the reaction possible.<br><br>It seems at first sight that for interesting molecules this is OK, namely because it looks that for the molecule from [1], say, there is always an interaction between a small molecule (the one which floats around) and a main big molecule.<br><br>But this is not true in the case of the Ackermann molecule. You see in this animation a moment where the big molecule splits into roughly 2 big parts and a smaller one.<br><br>So locality cannot be implemented by using the (1\u0027), (1\") pair of simpler reactions than (1).<br><br>Which is nice because what you see is not how it works, you don\u0027t see the rewrite enzymes!<br><br><br>[1] How it works<br><a href=\"collection.html#243\" onclick=\"location.hash = 243; StartingPost();\">show</a>"}, 
{"title": "ackermann_2_2_tangled.gif",
  "description": "Bilateral symmetry. This worm like molecule, with obvious symmetries, is the close cousin of the Ackermann(2,2) molecule [1], with only a pair of bonds rewired:<br><br>- replace line 14 \"FO ss1 4s1 7s1\" by \"FO ss1 4s2 7s1\"<br>- replace line 26 \"FO ss2 4s2 7s2\" by \"FO ss2 4s1 7s2\"<br><br>these two FO nodes are, each, an element of a successor lambda term.<br><br>If you wonder if the port variables like \"ss1\", \"4s2\", ... have any meaning, well, they don\u0027t. You can replace them by any string (in UTF-8 encoding) which does not contain a space or a newline character. But mind that each variable, say, like \"ss1\" appears twice in the mol file, for example \"ss1\" appears not only in line 14, but also in line 9: \"L 2s1 ss1 1s1\", thus expressing a bond between a port of the lambda node and the input port of the FO node.<br><br>(To be completely correct, any variable appears at most twice, when it does appear once it corresponds to a bond with a free end. The awk script adds to the mol file nodes \"FRIN\" (i.e. free in) or FROUT (i.e. free out) at these free ends, so eventually we always work with a mol file where indeed each variable appears exactly twice.)<br><br><br><br>[1] <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/ackermann_2_2.mol\">ackermann_2_2.mol</a>"}, 
{"title": "ackermann_2_try_actor.gif",
  "description": "Artificial complexity, actors version."}, 
{"title": "ackermann_2_try.gif",
  "description": "Medusa. Owing that I temporarily forgot what\u0027s that misleading English name for a medusa, I did some internet searching and felt over a passage from a letter by Jack London: \"But, after all, what squirming anywhere, damned or otherwise, means anything? That\u0027s the question I am always prone to put: What\u0027s this chemical ferment called life about?\"<br>I found it quoted in Jack London\u0027s Medusa of Truth by Per Serritslev Petersen [1].<br><br>I always loved Jack London. Now I know better why.<br><br>I had to manipulate this medusa, to keep it in the animation frame, as you can see.<br><br>[1] <a href=\"http://muse.jhu.edu/journals/phl/summary/v026/26.1petersen.html\">link</a>"}, 
{"title": "ackermann_3_2_64x.gif",
  "description": "Meaning, time dependent. This is a 64X speed screencast of a small piece of the animation which shows a meaningful computation with the artificial chemistry chemlambda. (It is the computation of Ackermann(3,2).) What\u0027s the problem with it?<br><br>Several.<br><br>1. Although the computation of the script which creates the animation is short and poses no problems to the computer, the visualization in the browser is harder.<br><br>2. For the human who tries to make sense of what he sees, it is meaningless. For two reasons:<br>- they are not human friendly; the cascades of rewrites are random, they don\u0027t follow a preconceived programmer idea<br>- the whole animation takes more than 90 min [1]<br><br>3. However, at 64X speed, we can notice that there is something happening, we start to see some meaning into it. At this speed, we could see the whole animation in about a minute and a half.<br><br>Although a min and 1/2 to notice that some \"bags\" of nodes duplicate, some morph into others and some rearrange wrt to others, without any chance to understand why, where exactly and how, this is a bit too much for a show.<br><br>But this raises interesting questions:<br><br>1. Do we need to understand the computation or it is enough to see that it works because it gives the right answer?<br><br>2. Do we need to constrain the computation in order to fit in our feeble analytic capacities?<br><br>Further I\u0027ll move the goalposts in the following way:<br>- the computation may be an animation of this virtual chemistry or it may be what the observer records via a measuring device (microscope) looking at a real molecular computation like in the Molecular computers proposal [2]<br><br>Then, other questions:<br><br>3. (Human observer, real chemistry) Can we understand more than empirical, black-boxed mechanisms of complex biochemical reactions? Without AI help, just observing this results only into a story which misses all details (this is a computation of Ackermann(3,2)) and transforms it into: there are some bags on some wires, the bags can replicate, some eat and displace others [5], therefore if we use some external instruments we can fiddle with these reactions and use them to make some humanly understandable work, like in synthetic biology where we make boolean gates from living cells, or when we make CA from crystallized DNA.<br><br>4. (Human observer, virtual chemistry) I can\u0027t use this because I can\u0027t figure what it means. (Can be used though, as proved by visionary precendents, like ALCHEMY [3] and Tierra [4], but the bottleneck seems to be in the human understanding X time needed to get interesting developments.)<br><br>5. (AI observer, virtual chemistry) Untried setting, that would be interesting to see.<br><br>6. (AI observer, real chemistry) An AI which makes interesting biochemical inferences from observations of real chemistry is a wonderful tool, and there are more and more results in this direction. However, I wonder if it could figure what this is all about.<br><br>[1] <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/ackermann_3_2.html\">ackermann_3_2.html</a><br><br>[2] <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/molecular.html\">link</a>, <a href=\"https://arxiv.org/abs/1811.04960\">arXiv:1811.04960</a><br><br>[3] <a href=\"http://tuvalu.santafe.edu/~walter/AlChemy/Statement/organization.html\">link</a><br><br>[4] <a href=\"http://life.ou.edu/pubs/charrel/rapportA4.ps\">link</a><br><br>[5] <a href=\"https://chemlambda.wordpress.com/2015/02/18/numberphile-microbe/\">link</a>"}, 
{"title": "ackermann_3_2_experia_short.gif",
  "description": "Experia shows the tree, as can be seen in this short animation of the beginning of the ackermann_3_2 computation with quiner_experia. (Smoother evolution, visualisation which privileges edges over nodes.)<br><br>There is already a demo [1] for the factorial of 4, done with quiner_experia. (Can be seen with safari or chromium, not with firefox which can\u0027t handle both the type police and doing the job. The fox should wear a kepi.)<br><br>Now, the interesting question is: why should the evolution of the molecule pass by a tree stage?<br><br>The answer I suggest is: it doesn\u0027t, it\u0027s the programmer bias. From all the molecules, this one is designed from a lambda term. Even if the reduction gives intermediate molecules which do not represent lambda terms, the cause of the trees is in the currying and more generally in the way the term is conceived.<br><br>[1] <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/lisfact_2_mod_experia.html\">lisfact_2_mod_experia.html</a>"}, 
//{"title": "ackermann_3_2_X128.gif",
//  "description": "Ackermann(3,2): There can be only one value computed, you see it accumulating in the upper left corner. So, where are the other, intermediary values? They are not. The only pieces of the graph which make sense are the small (one red, two green) bags, these are 1\u0027s, and (3 red, 4 green) bags, these are SUCC (successors).<br><br>Therefore, one can\u0027t even compare what happens in this random reduction of ackermann_3_2.mol (from the chemlambda repository) with other reduction algorithms, because all of them are based on some values and evaluations!<br><br>Very strange! If you have another informed opinion then react.<br><br>This is 128X sped of a screencast done with quiner (all weights set to 1, to be sure it ends I took cycounter\u003d2000), and with ackermann_3_2.mol from the repository, see the README [1] or check for other Ackermann related animations in the chemlambda collection.<br><br>[1] <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "ackermann_3_3_tangled.gif",
  "description": "The brain worm is the Ackermann(3,3) molecule modified as it was Ackermann(2,2) in the post [1].<br><br>[1] Bilateral symmetry<br><a href=\"collection.html#50\" onclick=\"location.hash = 50; StartingPost();\">show</a>"}, 
{"title": "ackermann_4_0_backw.gif",
  "description": "From dusk till dawn. The Ackermann(4,0) computation, with the settings from the post [1], seen backwards.<br><br>Done with the file ackermann_4_0.mol (check out the other ackermann_ mol files as well) and with a small modification of the quiner script [2].<br>The visualisation of the result takes 18 min (on safari). I made a screencast and then sped it up, progressively, to 128X, played backwards.<br><br>The purpose? To see if my brain can detect the change of the time arrow.<br><br>Due to the fact that the rewrites are not symmetric wrt time, and also to the fact that real chemical reactions are reversible (with certain probabilities), it is interesting to explore if it is reasonable to consider reversible rewrites as well.<br><br>In the first version of chemlambda [3], called the \"Chemical concrete machine\", I considered reversible rewrites. Later, I simplified the model to irreversible rewrites.<br><br>The problem is with the A-L rewrite (aka the BETA rewrite of Wadsworth and later Lamping, but used outside the tiny realm of lambda calculus) and with the FI_FOE rewrite, visible in this animation due to the colour choices (only the FI, FOE, FRIN, FROUT and T nodes are coloured otherwise than white). These rewrites, in the sense they have in chemlambda, give a pair of arrows (i.e. bonds) after application.<br><br>Therefore, if we take the inverse rewrites, we would have to pick at random a pair of bonds and apply the rewrite(s) backwards.<br><br>It is delicate because there are about n^2 places for such backwards rewrites, where n is the number of atoms. A bit too many, right?<br><br>One could consider, with low probability (but dependent on the number of atoms, lower as the atom numbers grow bigger) that the A-L and FI-FOE may occur backwards. The mechanism for this would be that the number of enzymes for the moves is limited (see in the Chemical concrete machine article, from p.5 the description of the enzymes related to rewrites). This is for later, although the external limitation of the number of enzymes, and the fact that they are considered on another level, higher than the molecules, are just examples of the common mistakes an old thinking person would make :)<br><br>[1] Signal transduction made visible<br><a href=\"collection.html#115\" onclick=\"location.hash = 115; StartingPost();\">show</a><br><br>[2] README.md at<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[3] Chemical concrete machine<br>- at figshare: <a href=\"https://figshare.com/articles/Chemical_concrete_machine/830457\">link</a><br>- at arXiv: <a href=\"https://arxiv.org/abs/1309.6914\">arXiv:1309.6914</a>"}, 
{"title": "ackermann_4_0_fast.gif",
  "description": "Ackermann again. Chemlambda passes with flying colors the test of the Ackermann function. Here is a sped up animation of Ackermann(4.0)\u003d13.<br><br>See the Rosetta code page on the Ackermann function:<br><a href=\"https://rosettacode.org/wiki/Ackermann_function\">link</a><br><br>I included this in the demos page of the chemlambda project:<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/ackermann_4_0.html\">ackermann_4_0.html</a><br><br>See it with safari or chromium (or chrome) but not with firefox, because firefox can\u0027t handle it (why? my guess is that it is because of the gecko engine, anyway it is not because of the calls in the js. Still don\u0027t know how to fix this, it comes from d3.js. Of course that the fault is mine in the first place, but the debugger points to a problem with prototypes coming from d3.js. I don\u0027t know how to fix it, nor I have found any solution on the net.)"}, 
{"title": "ackermann_4_1_goo.gif",
  "description": "Ackermann goo, or Ice-nine, a glimpse of it. In the last post [1] I describe a scenario where small Ackermann molecules made with RNA (see the announcement [2]) may lead to a grey goo situation.<br><br>Grey goo [3] is a hypothetical result of uncontrolled replication of nanodevices. In real world it would be limited by the resources available. After all what stops a bacteria to replicate forever, until it uses all Earth resources? Well, the availability of them.<br><br>In this Ackermann goo scenario, if we use a molecule for Ackermann(4,4), say, then the number of the atoms would be larger than the whole number of atoms in the universe. However, there is an availability problem: all rewrites are done by rewrite enzymes, so in reality a solution which contains some ackermann molecules and enzymes will turn into a (grey? what color?) goo, then stops because there are no more available enzymes capable to achieve the key positions for new rewrites.<br><br>But just imagine that the enzymes are not some weird artificial ones, but real ones from almost any living cell. Then, if you stick your finger into the goo... Ice-nine! Only not with water. What\u0027s Ice-nine? [4]<br><br>This scenario is faulty though. Because if real enzymes are involved as rewriting enzymes of RNA, then the same might happen all the time, everywhere, because they are all abundant in the living realm. So why it does not happen? Sometimes it does, most of the time it doesn\u0027t, it\u0027s resource availability, as usual.<br><br><br>The following announcement is by default included in the chemlambda posts, because is important:<br><br>Announcement: there exists an encoding of chemlambda molecules with RNA, in such a way that the chemlambda model can be realized via real RNA computing. I open a bidding session concerning a contract based collaboration which could convince me that you\u0027re an expert and you can provide me with the means to do this together. As concerns the collaboration, I shall give you an edge into being the first who does it. Letters of interest may be addressed to Marius.Buliga@gmail.com, Marius.Buliga@imar.ro or via the chemlambda repository (gh-pages branch) [5]. Follow this post for updates.<br><br>UPDATE 1: the announcement is now also on my math research homepage [6] and at the chorasimilarity blog [7]. Appears on twitter at @mbuliga as well. So you have these 3 supplementary places to look for updates, especially [7] for details about motivations and how it does fit with my other interests.<br><br><br>[1] 4 ackermann runs in parallel<br><a href=\"collection.html#47\" onclick=\"location.hash = 47; StartingPost();\">show</a><br><br>[2] Announcement: there exists an encoding of chemlambda molecules with RNA, in such a way that the chemlambda model can be realized via real RNA computing<br>[3] Grey goo<br><a href=\"https://en.wikipedia.org/wiki/Grey_goo\">wikipedia</a><br><br>[4] Ice-nine<br><a href=\"https://en.wikipedia.org/wiki/Ice-nine\">wikipedia</a><br><br>[5] <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[6] <a href=\"http://www.imar.ro/~mbuliga/\">homepage</a><br><br>[7] <a href=\"https://chorasimilarity.wordpress.com/2016/09/29/announcement-chemlambda-can-be-done-with-rna/\">link</a>"}, 
{"title": "ackermann_4_4_75steps.gif",
  "description": "Ackermann(4,4) goo may be indiscernible from life. See the post [1] for the Ackermann goo scenario.<br><br>In that post I used Ackermann(4,1). In this one I use Ackermann(4,4). This is such an immense number that there is hopeless to think that a physics based computation can achieve it, by representing the lambda term for it (the result I mean, as a Church number) with atoms or small molecules.<br><br>However, with chemlambda we may take a look at how the computation unfolds. And the look of it is more complex than [1].<br><br>So complex that it makes me wonder if Ackermann(4,4) computation is indiscernible from life. Oh, OK, what if Ackermann(5,5) is? Let me explain.<br><br>In chemlambda there is a notion of a quine as a proposal for life. A quine is a molecule which under deterministic reduction has a cyclical evolution. Under random reduction such a molecule has good properties for being alive (has a metabolism, capable of reproduction).<br><br>Now, chemlambda quines correspond to programs which implement primitively recursive functions, that is algorithms which can be expressed by a given number of for loops, say.<br><br>Functions which are recursive, but not primitively recursive can be computed by an algorithm, but the number of for loops depends on the input of the function, roughly.<br><br>There is a second aspect, namely that a pool of quines is a bigger quine and moreover a big collection of molecule which is a quine may be seen as an environment where some smaller parts (think about the ouroboros walker on it\u0027s track) consume and produce other parts.<br><br>Why not suppose that life as a whole could be a chemical construct akin to a recursive but not primitive recursive function?<br><br>Why not suppose that this function is simple?<br><br><br><br><br>The following announcement [2] is by default included in the chemlambda posts, because is important:<br><br>Announcement: there exists an encoding of chemlambda molecules with RNA, in such a way that the chemlambda model can be realized via real RNA computing. I open a bidding session concerning a contract based collaboration which could convince me that you\u0027re an expert and you can provide me with the means to do this together. As concerns the collaboration, I shall give you an edge into being the first who does it. Letters of interest may be addressed to Marius.Buliga@gmail.com, Marius.Buliga@imar.ro or via the chemlambda repository (gh-pages branch) [3]. Follow this post for updates.<br><br>UPDATE 1: the announcement is now also on my math research homepage [4] and at the chorasimilarity blog [5]. Appears on twitter at @mbuliga as well. So you have these 3 supplementary places to look for updates, especially [5] for details about motivations and how it does fit with my other interests.<br><br><br>[1] Ackermann goo or Ice-nine<br><a href=\"collection.html#58\" onclick=\"location.hash = 58; StartingPost();\">show</a><br><br>[2] Announcement: there exists an encoding of chemlambda molecules with RNA, in such a way that the chemlambda model can be realized via real RNA computing<br>[unavailable]<br><br>[3] <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[4] <a href=\"http://www.imar.ro/~mbuliga/\">homepage</a><br><br>[5] <a href=\"https://chorasimilarity.wordpress.com/2016/09/29/announcement-chemlambda-can-be-done-with-rna/\">link</a>"}, 
{"title": "ackermann_4_4_space_short.gif",
  "description": "Ackermann(4,4) goo with space constraints. What you see is the first simulation of the \"indiscernible from life\" [1] Ackermann(4,4) computation in the presence of space constraints.<br><br>In the post [2] I explained an in vitro experiment where is shown a typical contiguous piece of an artificial cell chemlambda prototype, reduced in isolation from the whole cell. The piece is about 1/20 of the whole cell. By \"contiguous\" I mean a contiguous portion of the mol file of the whole cell.<br><br>There is a (very simple) space in the mol file. Imagine that you map any node of the mol file to the real axis, so that the node goes to it\u0027s position in the list. This gives also a distance function between two nodes, as the distance between their positions.<br><br>Now, imagine that you add a space condition to the reaction between the rewrite enzyme and the rewrite pattern, namely that it can happen (with a given probability, of course) only if the distance between the nodes from the pattern is smaller than a constant. It the distance is greater than it won\u0027t happen.<br><br>This space condition models (a very simple, agreed) space influence on the chemical reactions. For example, the reactions from the isolated contiguous piece of the said mol file can happen only because the space constant is smaller than the length of the piece, see?<br><br>I took as the subject of this experiment the ackermann_4_4.mol which was the subject of [1] as well, only this time I was able to pass it directly by the random reduction algorithm with space conditions.<br><br>The animation does not do justice to this complex beauty, because it is sped up from the original 30 min to just about 10 s, but anyway, you can see once more something really new.<br><br>Is it alive? Does it starts to build really complex structure?<br><br>In more rigorous terms, such a reduction algorithm with space conditions is somewhere between a purely local graph rewrite system and a term rewrite system. More later, there are huge advances ahead :)<br><br>[1] Ackermann(4,4) goo may be indiscernible from life<br><a href=\"collection.html#59\" onclick=\"location.hash = 59; StartingPost();\">show</a><br><br>[2] In vitro<br><a href=\"collection.html#183\" onclick=\"location.hash = 183; StartingPost();\">show</a>"}, 
{"title": "ackermann_mny_mauve2.gif",
  "description": "Artificial complexity 2. Another example, using the same molecule [1], as the previous [2].<br><br>[1] <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/ackermann_mny.mol\">ackermann_mny.mol</a><br><br>[2] Artificial, real, artificial complexity<br><a href=\"collection.html#46\" onclick=\"location.hash = 46; StartingPost();\">show</a>"}, 
{"title": "ackermann_spiral_short.gif",
  "description": "Ackermann function with tube constructor. I took the Ackermann(2,2) molecule and replaced one of the successor terms with the tube constructor. I wrote many times about various Ack(m,n) computed with chemlambda. The first demo is <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/random_ackermann_2_2.html\">ackermann_2_2.html</a> If you want to play with them then go to the repository and try the scripts with one of the mol files which have ackermann in the name."}, 
//{"title": "ack_mod.gif",
//  "description": "Call by value, call by need, call by any other name ... but this animation shows what I mean when I say that there is no evaluation involved in the reduction process of a lambda term, as seen in chemlambda.<br><br>First, explanations about what you see.<br><br>1. This is a 64X sped screencast of the random evolution of a molecule which computes the value of Ackermann(3,2). Because it takes time, you see the second half of the evolution.<br><br>2. There are several things like small leaves made of small dots, and something like a growing ladder made also of small dots. This is because of a mechanism in the script which turns old nodes into dots. You can see therefore the parts of the molecule-graph where no chemical reduction happen.<br>Remember further these: small leaves and the ladder.<br><br>3. Towards the end of the animation there is another mechanism which turns the color of new nodes to black. In the script this happens if the number of new nodes becomes \u003e 10000 (when we count only the main nodes; with their ports, that means that the mechanism starts when the number of new nodes, main and ports, becomes greater than 40000).<br>This is another way to visualize the metabolism of the molecule, that is the process where the nodes are refreshed bu the whole structure remains.<br><br>Now, about lambda terms and chemlambda molecules.<br><br>4. There is an algorithm described in section 3 of Graphic lambda calculus [1] for turning lambda terms into graphs. As chemlambda is a development of GLC, the same algorithm is used here and in all other example which are about lambda terms as molecules.<br><br>You can see a more visual description of the process in part IV [2] and part V [3]  of this chemlambda tutorial. (Mind that there is no mention of FOE nodes, because this is about chemlambda v1, but the algorithm and the description are the same.)<br><br>Roughly, that\u0027s what you do to turn a lambda term into a molecule:<br>- first build the syntactic tree of the term, by using (green) A nodes for applications and (red) L nodes for lambda abstraction<br>- then eliminate the variables by adding trees of (green) FO nodes, with roots at variables in a lambda abstraction and leaves where the variables appear under the scope of that abstraction; free variables appear as FRIN (free in) nodes and variables under lambda abstractions which do not appear in the scope are replaced by T (black, terminal) nodes.<br><br>So a lambda term, when seen as a molecule, looks like a tree with leaves which may be glued ones with others. It is typically a graph which has cycles, it looks visually as a bag with one stem, or as a big leaf.<br><br>If, for example, the term is made by a collection of combinators then it looks as a tree with leaves being the combinators bags.<br><br>Some particular examples:<br>- numbers in Church encoding look like ladders of pairs of green (A and FO) nodes, with the ends connected via a pair of L (red) nodes and one lonely A (green) node.<br>- more particular, the number 1 appears as such a ladder structure with only one pair of green nodes, so visually it really looks like a small bag.<br>The small leaves in the animation are numbers 1.<br>- the successor term looks like a lightly bigger bag, with 3 red nodes. You can see successors appearing, morphing and disappearing all over the place in the animation.<br><br>About the reduction process.<br><br>5. The reduction in chemlambda with the so-called stupid random algorithm is, well, random. There is no other strategy.<br><br>6. But this reduction does not preserve lambda terms molecules! Yes, because all rewrites are local, they are applied without any concern about the global shape of the molecules involved.<br><br>7. Which means that, literary, there is no evaluation! Because there are no values which are replaced by terms.<br><br>You can see this in the animation. The graph-molecule is represented in an arbitrary embedding in the plane (mind that bonds may cross, the embedding is not planar, because the graphs are typically not planar).<br><br>There is a cartoon physics provided by d3.js with elastic bonds and a gravity field with the center in the center of the image.<br><br>Therefore, a graph which would be like a tree with glued leaves, it would appear as a tree structure with some small or big leaves, curled around the center of gravity.<br><br>You see that this is not the case here!<br><br>The graph appears indeed as a curled, almost cylindrical structure, with a ladder structure at one end and then with a very non-tree shape which curls in the clockwise sense around the center of gravity.<br><br>There are some leaves, however:<br>- the small ones, which are 1\u0027s, which are non-reactive (made of old nodes) and they migrate towards the end of the structure, in clockwise direction<br>- some bigger ones, which morph all the time, then they reappear, going in counterclockwise direction, these are successors. They are very reactive.<br><br>8. So what happens is that there are no evaluations, but there is signal transduction, as in the example from [4] with the two walkers.<br><br>9 OK, accepting that there are no values replaced by terms, accepting that signal transduction replaces this evaluation (and works without any higher control!) does this correspond ina vague sense to an eager, lazy, call by need, evaluation of the lambda term for the Ackermann(3,2)?<br><br>The fact that the small leaves (i.e. 1s) are non-reactive and they migrate towards the \"bottom\" of the graph seems to indicate that it\u0027s a kind of lazy evaluation.<br><br>The fact that the successors morph and are transmitted towards the \"top\" of the graph, as well as the ladder structure at the top (which is the value of the function, in the making) indicates a kind of eager evaluation.<br><br>Conclusion. Needs serious thinking, there is a lot to dig here and ignorant or snobbery opinions that this is something like (choose randomly in your comfort zone): geometry of interaction, category theory point of view on lambda calculus, lambda calculus with a reduction strategy, just another graph rewrite system, functional programming,<br>are not helpful, nor accurate.<br><br><br><br><br>[1] Graphic lambda calculus<br><a href=\"https://arxiv.org/abs/1305.5786\">arXiv:1305.5786</a><br><br>[2] Lambda calculus and the fixed point combinator in chemlambda, part IV<br><a href=\"https://chorasimilarity.wordpress.com/2014/07/16/lambda-calculus-and-the-fixed-point-combinator-in-chemlambda-iv/\">link</a><br><br>[3] Lambda calculus and the fixed point combinator in chemlambda, part V<br><a href=\"https://chorasimilarity.wordpress.com/2014/07/16/lambda-calculus-and-the-fixed-point-combinator-in-chemlambda-v/\">link</a><br><br>[4] Signal transduction<br><a href=\"collection.html#244\" onclick=\"location.hash = 244; StartingPost();\">show</a>"}, 
{"title": "attack_defense.gif",
  "description": "Attack and defense. While waiting for substantially more computing power and more clever graphical tools, I continue from the last post by showing you a composite animation. It is made from two simulations (using two molecules which I\u0027m currently building) and just a small bit of d3.js magic, ending with some trivial gif after effects."}, 
{"title": "baez_s.gif",
  "description": "John Baez Azimuth blog [0] uses a chemlambda animation without attribution. Chemlambda is mesmerizing but it is an Open Science project. Be correct. I made a post [1] with comments on this.<br><br>This happened before (by others). I agree fully to reuse any part of chemlambda with attribution!<br><br>[0] <a href=\"https://johncarlosbaez.wordpress.com/2018/10/02/applied-category-theory-2019/\">link</a><br><br>[1] <a href=\"https://chorasimilarity.wordpress.com/2018/10/04/john-baez-applied-category-theory-2019-post-uses-my-animation-without-attribution/\">link</a>"}, 
{"title": "bbdupli.gif",
  "description": "This animation starts with one Turing Machine and ends with three Turing Machines.<br>Huh?<br>Let\u0027s take it slower.<br><br>1. Everybody knows what is a TM. Computers are the real thing which resembles most to a TM. There is lot of stuff added, like a screen, keyboard, a designer box, antennas and wires, but essentially a computer has a memory which is like a tape full of bits (0 and 1) and there is a processor which is like a read/write head with an internal state. When the head reads a bit from the tape then the internal state changes, the head writes in the tape and then moves, according to some internal rules.<br><br>2. These rules define the TM. Any rule goes, but among them there are rules which make the TM universal. That means that there are well chosen rules such that if you first put on the tape a string of bits, which is like the OS of the computer, and if you place the head at the beginning of this string, then the TM (which obbeys those clever rules) uploads the OS and then it becomes the TM of your choice.<br><br>3. From here it becomes clear that these rules are very important. Everything else is built on them. There are many examples of rules for universal TM, the more or less precise estimate is that for a tape written with bits (0 and 1) the known universal TM need about 20 rules.<br><br>4. Just a little bit earlier than the TM invention, lambda calculus has been invented as well, by Alonzo Church. Initially the lambda calculus was a monumental formalism, but after the TM invention there was a variant of it, called untyped lambda beta calculus, which has been proved to be able to compute the same things as a TM can compute.<br>The untyped lambda beta calculus is famous among the CS nerds and much less known by others (synthetic biologists, I\u0027m looking at you) who think that TM are the natural thing to try to emulate with biology and chemistry, because it is obviously something everybody understands, not like lambda calculus which goes into higher and higher abstractions.<br>There are exceptions, the most famous in my opinion is the Algorithmic Chemistry (or Alchemy) of Fontana and Buss. They say that lambda calculus is chemistry and that one operation (called application) of LC is like a chemical reaction and the other operation (called abstraction) is like a reactive site. (Then they change their mind, trying to fit types into the story, speaking about chemicals as functions, then they use pi calculus, all very interesting but outside of the local goal of this post. Will come back later to that.)<br><br>Such exceptions aside, the general idea is: TM easy, LC hard.<br><br>That is false and I shall prove it.<br><br>5. If we want to compare TM with LC then we have to put them on the same footing, right? This same footing is to take the rules of TM and the reductions of LC as rewrites.<br><br>Which is done here (it\u0027s weekend and my program changed suddenly)<br><br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/turingchem.html\">link</a><br><br>Conclusions:<br><br>- LC is actually much simpler than TM, because it uses only one rewrite which is specific to it (the BETA rewrite) instead of about 20 min for the TM<br>- LC and TM are both compatible with the chemical approach a la chemlambda, in the sense that chemlambda can be enhanced by the addition of \"bits\" (red and green 2 valent nodes), head move (Arrow element) and TM internal states (other 2-valent nodes) and by some \"propagation\" rewrites, such that chemlambda can now do both TM and LC in the same time!<br><br>In the animation you see, at the beginning, something like<br>- a tree made of green fanout (FO) nodes (and yellow FRIN and magenta FROUT leaves) and<br>- a small ring of green (2-valent, bit 0) and pale green (a state of a TM). That small ring is a TM tape which is \"abstracted\", i.e. connected to a lambda abstraction node, which itself is \"applied\" (by an application A node) to the fanout tree.<br><br>What happens? Eventually there are produced 3 TM (you see 3 tapes) which function independently.<br><br>They are actually in different states, because the algorithm which does all this is random (it does a rewrite if a coin has the fancy to drop in the right state)."}, 
{"title": "beta.gif",
  "description": "The beta reduction from lambda calculus is easy to be understood as the command<br>let x\u003dB in A<br>It corresponds to the term (Lx.A)B which reduces to A[x\u003dB], i.e to the term A where all instances of x have been replaced by B.<br>(by an algorithm which is left to be added, there are many choices among them!)<br><br>In Christopher P. Wadsworth, Semantics and Pragmatics of the Lambda Calculus , DPhil thesis, Oxford, 1971, and later John Lamping, An algorithm for optimal lambda calculus reduction, POPL '90 Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming languages, p. 16-30, there are proposals to replace the beta rule by a graph rewrite on the syntactic tree of the term.<br><br>These proposals opened many research paths, related to call by name strategies of evaluations, and of course going to the Interaction Nets.<br><br>The beta rule, as seen on the syntactic tree of a term, is a graph rewrite which is simple, but the context of application of it is complex, if one tries to stay in the real of syntactic trees (or that of some graphs which are associated to lambda terms).<br><br>This is one example of blindness caused by semantics. Of course that it is very difficult to conceive strategies of applications of this local rule (it involves only two nodes and 5 edges) so that the graph after the rewrite has a global property (means a lambda term).<br><br>But a whole world is missed this way!<br><br>In chemlambda the rewrite is called BETA or A-L.<br>see the list of rewrites<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/moves.html\">link</a><br><br>As you see this is a Wadsworth-Lamping kind of graph rewrite, with the distinctions that:<br>(a) x, A, B are only ports variables, not terms<br>(b) there is no constraint for x to be linked to A (no need to be sure that x is \"in\" A)<br><br>The price is that even if we start with a graph which is related to a lambda term, after performing such careless rewrites we get out of the realm of lambda terms.<br><br>But there is a more subtle difference: the nodes of the graphs are not gates and the edges are not wires which carry signals.<br><br>The reduction works well for many fundamental examples,<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/demos.html\">chemlambda demos</a><br>by a simple combination of the beta rewrite and those rewrites from the DIST family I wrote about in the post about duplicating trees.<br><a href=\"https://chorasimilarity.wordpress.com/2015/05/04/the-illustrated-shuffle-trick-used-for-tree-duplication/\">link</a><br><br>So, we get out of lambda calculus, what\u0027s wrong with that? Nothing, actually, it turns out that the world outside lambda, but in chemlambda, has very interesting features. Nobody explored them, that is why is so hard to discuss about that without falling into one\u0027s preconceptions (has to be functional programming, has to be lambda calculus, has to be a language, has to have a global semantics).<br><br>In the animated gif the yellow nodes which connect A with let and x with B are Arrow elements, which disappear after COMB moves."}, 
{"title": "betazipper.gif",
  "description": "Zipper logic is an alternative of the artificial chemistry chemlambda, where instead of the molecules which interact with invisible enzymes, there are half-zippers which interact with complementary ones.<br><br><a href=\"https://arxiv.org/abs/1405.6095\">arXiv:1405.6095</a><br><br>I hoped at some moment to link this with pseudoknots (a secondary structure of RNA)<br><br><a href=\"https://en.wikipedia.org/wiki/Pseudoknot\">link</a><br><br>In the animation you see how zippers appear in chemlambda. This is a beta zipper, which is made by two half-zippers:<br>- the string of red nodes (up) is a half-zipper<br>- the string of green nodes (down) is the complementary half zipper<br><br>It is called a beta zipper because it works (zips) by a succession of BETA rewrites. After all, the red nodes are called lambdas and the green ones are called applications.<br>You can safely ignore these allusions to lambda calculus, because technically chemlambda is only remotely related to lambda calculus.<br><br>Is this a random rewrite sequence or a deterministical one? It does not matter, because at each stage there is only one rewrite possible, so the evolution is deterministical in this case, even if you use a random rewrite algorithm.<br><br>How I did the animation:<br>- instructions here <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>You may wish to go to the page of other demos<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/demos.html\">chemlambda demos</a><br>or<br>you may want to see more about this project (there are lots of pages to see) at the chemlambda index<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/index.html\">link</a><br>WHOAMI<br><a href=\"http://imar.ro/~mbuliga/\">homepage</a>"}, 
{"title": "bigpred_28_quine_hyb_var_mola.gif",
  "description": "Hibridization is a derivative. Would be long to explain, in detail, in a post, therefore I show you by way of experiments. This is the first one.<br><br>Hibridization of two molecules in chemlambda means a switch of two bonds of two different molecules, done in certain places. Which places? In many simulations done before, that was a matter of study of individual molecules.<br><br>Btw, the creation of a new molecule is, in many cases, work intensive. That is why I see, for example, the library of chemlambda molecules as a result of a year of work. You should pass over the beautiful images and realize that these are real simulations. Each one of them would need many pages of explanations, in the passive but precise and detailed article style.<br><br>Back to explanations. There\u0027s a hidden interest I have with chemlambda, because I see it as a degenerated version of a computation model which would contain also the emergent algebra sector of the older graphic lambda calculus. Think about emergent algebras as being graph rewrite versions of linear algebra, but without a passive space of coordinates behind and going far away from commutativity (a linear object in an emergent algebra is a generalization of a nilpotent group, or a morphism between such groups...).<br><br>Emergent algebras have an associated differential calculus. There should therefore exist a variant of this calculus in chemlambda.<br><br>There is one and it turns out that derivatives are certain hybridizations. Moreover, chemlambda quines are those molecules with trivial derivatives.<br><br>In practice that means it is possible to use hybridisation as a tool for assembling molecules so that their interactions are controlled in several ways.<br><br>Application: in this simulation there is a hybrid between an ouroboros, or walker molecule (appears as \"bigpred\" in several mol files, it is related to the predecessor in lambda calculus) and a 28 quine. I use actor colors and colored rewrites to make these ingredients visible.<br><br>The 28 quine is yellow, the ouroboros is mauve and in red it\u0027s the track where it walks.<br><br>I hybridized them in a certain way, suggested by the considerations before.<br><br>What you see is the following. The ouroboros, or walker, runs over the track, most of the time as if it does not care it has been hybridized with the yellow quine. Showed you before that walkers travel through actors, they are like signals propagating through a net.<br><br>The yellow 28 quine preserves it\u0027s actor color and it is active only when interacting with the ouroboros. So, as you see, after the ouroboros gets far on the track, the yellow quine becomes inactive, only to start to work again when the ouroboros come close again."}, 
{"title": "bigpred_bif.gif",
  "description": "Hybridised ouroboros. I took two ouroboros exemplaries [1] (stored in bigbred_train.mol) and produced the molecule bigpred_bif.mol by hybridisation [2] of the two creatures. After a few steps the two ouroboros(es?) disentangle and leave behind two Holliday junctions [3] which mix the two train tracks. They pass again by this tracks mix and they leave it as it was.<br><br>This animation resembles with [4], where two molecules representing the predecessor have been mixed by one Holliday junction.<br><br>[1] Ouroboros, the first quine<br><a href=\"collection.html#76\" onclick=\"location.hash = 76; StartingPost();\">show</a><br><br>[2] How big an artificial molecule can be?<br><a href=\"collection.html#4\" onclick=\"location.hash = 4; StartingPost();\">show</a><br><br>[3] Holliday junction<br><a href=\"https://en.wikipedia.org/wiki/Holliday_junction\">wikipedia</a><br><br>[4] <a href=\"https://chorasimilarity.wordpress.com/2015/02/12/two-walkers-enter-into-a-holliday-junction/\">link</a>"}, 
{"title": "bigpred_penrose.gif",
  "description": "Quines in the \u002750s The first chemlambda quine, called the \"ouroboros\" (see story [1]) is strikingly similar with this demo from the \u002750s, done by Lionel and Roger Penrose [2].<br><br>[1] Ouroboros, the first quine<br><a href=\"collection.html#76\" onclick=\"location.hash = 76; StartingPost();\">show</a><br><br>[2] Automatic Mechanical Self Replication<br><a href=\"https://www.youtube.com/watch?v\u003d2_9ohFWR0Vs\">youtube</a>"}, 
{"title": "bigpred_train_actor.gif",
  "description": "Walker passing thru actors. For the walker, actors are like space. For the actors, the walker is a signal.<br><br>Done with bigpred_train.mola and quiner_node.sh from the chemlambda repository."}, 
//{"title": "bigpred_train_egg_mist_blue_superoptim.gif",
//  "description": ""}, 
{"title": "bigpred_train_egg_mist_blue.gif",
  "description": "Life at molecular scale. Recently there are more and more amazing results in techniques allowing the visualization of life at molecular scale. Instead of the old story about soups of species of molecules, now we can see individual molecules in living cells [1], or that the coiled DNA has a complex chemical configuration, or that axons and dendrites interact in a far more complex way than imagined before. Life is based on a complex tangle of evolving individuals, from the molecular scale onwards.<br><br>To me, this gives hope that at some point chemists will start to consider seriously the possibility to build such structures, such molecular computers [4] from first principles.<br><br>The image is a screencast of a chemlambda computation, done with quiner mist.<br><br>[1] Li et. al., \"Extended Resolution Structured Illumination Imaging of Endocytic and Cytoskeletal Dynamics,\"  Science. <a href=\"https://vimeo.com/136537187\">vimeo</a><br><br>[2] Structural diversity of supercoiled DNA, Nature Communications 6,Article number:8440doi:10.1038/ncomms9440,<br><a href=\"https://www.nature.com/ncomms/2015/151012/ncomms9440/full/ncomms9440.html\">link</a><br><br>[3] Saturated Reconstruction of a Volume of Neocortex, Cell, Volume 162, Issue 3, p648–661, 30 July 2015<br><a href=\"https://www.cell.com/cell/abstract/S0092-8674%2900824-7\">link</a><br>and video:<br><a href=\"https://youtu.be/nEOpUypJgyw\">youtube</a><br><br>[4] Molecular computers<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/molecular.html\">link</a>, <a href=\"https://arxiv.org/abs/1811.04960\">arXiv:1811.04960</a>"}, 
{"title": "bigpred_train_egg_mist_short.gif",
  "description": "Signal transduction whirls. Chemlambda animations can be tweaked to show clearly the signal transduction which runs this model of computation.<br><br>By tweaks I mean modifications in the d3.js output, by adding transitions and delays in colouring. In this case only the new nodes which appear are seen, after a short delay which let them settle in the modifying molecule.<br><br>The rest (old nodes, bonds) are coloured black.<br><br>You can clearly see a process of construction of the end molecule, which is done by a cascade of chemical reactions (i.e. by a random process of signal transductions).<br><br>This particular example is a rerun of the experia version of the two swirls<br>[unavailable]<br>See that post for references about how is done!<br><br>Only that I used a home-brewed, newer version of the experia which I call \"mist\". When I\u0027ll be sure it works nice, I shall put it in the chemlambda repository."}, 
{"title": "bigpred_train_egg.gif",
  "description": "Two swirls. I modified the permutation parts from the egg hatch animation [1] and I disconnected the trail. The molecule is in the file bigpred_train_egg.mol from the chemlambda repository.<br><br>The permutation used is the one given by addition of 7 modulo 30.<br><br>[1] An egg hatching<br>[unavailable]"}, 
{"title": "bigpred_train_perm.gif",
  "description": "Maze traversal. Instead of the tree traversal [1], I took a walker and it\u0027s track and doubled the track. Then I needed a permutation, so I looked into the output of synthetic script [2] applied to the 20 quine, because the 20 quine has 30 edges. I used the 30 elements permutation from the synthetic 20 quine and I grafted it on a half of the long track of the walker, so that when the computation starts it is going to mix the connections between the yellow FOE nodes side of the track and the green A nodes of the track. (Btw, I use a version of quiner which colours the FI nodes not with red_col, but with out_col; it does not worth an update of the quiner script only for that.)<br><br>This gives a walker which has half of the track entangled into a maze.<br>It does traverse it and you can see it well and healthy, walking along the straight half of the track, then entering again into the maze and going out, and so on.<br><br>Done with the file bigpred_train_perm.mol and quiner with the random algorithm settings [3].<br><br>[1] Tree traversal magic<br><a href=\"collection.html#77\" onclick=\"location.hash = 77; StartingPost();\">show</a><br><br>[2] Synthetic stuff<br><a href=\"collection.html#219\" onclick=\"location.hash = 219; StartingPost();\">show</a><br><br>[3] Chemlambda repository, README<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "bigpred_train.gif",
  "description": "Ouroboros, the first quine. I\u0027ve told the story of the first artificial organism in chemlambda [1], but I have not shown it exactly.<br><br>Here is it. It goes on and on and on...<br><br><br>It works as explained in [2], if you change everywhere the FO by FOE (so visually the green FO nodes by the yellow FOE nodes).<br><br>This is a random evolution done with bigpred_train.mol and the quiner script from the chemlambda repository [3].<br><br>[1] The story of the first artificial life organism in chemlambda.<br><a href=\"collection.html#196\" onclick=\"location.hash = 196; StartingPost();\">show</a><br><br>[2] Quines in chemlambda<br><a href=\"https://chorasimilarity.wordpress.com/2014/09/01/quines-in-chemlambda/\">post</a><br><br>[3] Chemlambda repository<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "bigpred_tree.gif",
  "description": "Tree traversal magic. A walker creature traverses a tree, in the random rewrites algorithm.<br>See the live demo at<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/bigpred_tree.html\">bigpred_tree.html</a><br>with the usual proviso to use chrome, chromium or safari to enjoy it better."}, 
{"title": "bits_new.gif",
  "description": "cyberpathogen infecting cell? No, only lambda calculus, the chemical version. What you see is (id id) replicated 64 times, where id\u003d\\x.x and the replication is done with a binary tree of FOE nodes with 64 leaves.<br>In the #chemlambda version the tree is most of what you see at the beginning and there is one initial \"id\", which appears as a red node. The id is to be replicated into a pair of ids, then one is applied to the other. This is a small 3 nodes molecule ( an id, a FO node for replication and a A node for application), is a small program which does something very simple: (id id) reduces to id. But then there is this big binary tree of FOE nodes which replicates the whole program, while it\u0027s running. Of course that during the replication the tree is consumed and progressively, as the replication advances, the tree is consumed and the various copies execute, at random times. The result are 64 red ids (I don\u0027t count the small nodes, 3/big node, these represent the ports.)"}, 
//{"title": "blobs_short.gif",
//  "description": "Blobs doing something. Perfect for 9s attention span."}, 
{"title": "boltzmann_3.gif",
  "description": "Mini Boltzmann brain. This is a neural network, sensibly bigger than [1], where the input is simulated by randomly and gradually allowing connections with input molecules and output is the disconnected part which is released. I am as curious as you what happens on longer time scales. In real browser time what you see takes about 40 min. The computing time of the html/js output is about 10s.<br><br>[1] Two neurons interacting<br><a href=\"collection.html#161\" onclick=\"location.hash = 161; StartingPost();\">show</a>"}, 
{"title": "boole.gif",
  "description": "FALSE is a hybrid of TRUE or how boolean values look in chemlambda.<br><br>Fact: booleans TRUE and FALSE can be expressed as lambda terms, which can then be turned into chemlambda molecules.<br><br>Then we can see how they work, geometrically.<br><br>The steps are the following:<br><br>1. Church encoding gives a way to define boolean values as terms in the lambda calculus.<br>It is easy:<br><br>TRUE\u003d Lx.(Ly.x)<br>FALSE\u003d Lx.(Ly.y)<br><br>So what? When we apply one of these terms to another two, arbitrary terms X and Y, look what happens:<br><br>(arrows are beta reductions (Lx.A)B - - \u003e A[x:\u003dB] )<br><br>(TRUE X) Y - - \u003e (Ly.X) Y - - \u003e X    (meaning Y goes to the garbage)<br><br>(FALSE X) Y - - \u003e (Ly.y) Y - - \u003e Y    (meaning X goes to the garbage)<br><br>It means that TRUE and FALSE select a way for X and Y: one of them survives, the other disappears.<br><br>Good: this selection is an essential ingredient for computation<br>Bad: too wasteful! why send a whole term to the garbage?<br><br>Then, we can see it otherwise: there are two outcomes: S(urvival) and G(arbage), there is a pair of terms X and Y.<br>- TRUE makes X to connect with S and Y to connect with G<br>- FALSE makes X to connect with G and Y to connect with S<br><br>2. The terms TRUE and FALSE appear as molecules in chemlambda, each one made of two red nodes (lambdas) and a T (termination) node.<br>But we may dispense of the T nodes, because they lead to waste, and keep only the lambda nodes.<br>So in chemlambda the TRUE and FALSE molecules are, each, made of two red (lambda) nodes and they have one FROUT (free out). They look almost alike, only they are wired differently.<br><br>We want to see how it looks to apply one term to X and then to Y, where X and Y are arbitrary.<br><br>In chemlambda, this means we have to add two green (A) application nodes, so TRUE or FALSE applied to some arbitrary X and Y appear, each,<br>as a 4 node molecule, made of two red (lambda) two green (A), with two FRIN (free in) nodes corresponding to X and Y and two FROUT (free out) nodes, corresponding: one to the deleted termination node, thus this is the G(arbage) outcome, and the other to the \"output\" of the lambda terms, thus this is the S(urvival) outcome.<br><br>3. But the configuration made of two green A nodes and two red L nodes is the familiar zipper which you can look at in the post<br><a href=\"collection.html#67\" onclick=\"location.hash = 67; StartingPost();\">show</a><br><br>In the animation you see TRUE (at left) and FALSE (at right), with the magenta FROUT nodes and the yellow FRIN nodes.<br>The zipper configurations are visible as the two vertical strings made of two green, two red nodes.<br><br>What\u0027s more? Zippers, they do only one thing: they unzip.<br><br>4. The wiring of TRUE and FALSE is different. You can see the TRUE and FALSE in the lower part of the animation.<br><br>I added four Arrow (white) nodes in order to make the wiring more visible. Arrow nodes are eliminated in the COMB cycle, they have only a fleeting existence<br>(COMB cycle? see the list of rewrites, mind that colours are different because the background is black, but you can still recognize the patterns, or just read the rewrites<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/moves.html\">link</a> )<br><br>This shows what is really happening: look at each (TRUE-left, FALSE-right) configuration.<br><br>In the upper side you have 4 nodes, two magenta, two yellow, which are wired together at the end of the computation. In the case of TRUE they end up wired in a X pattern, in the case of FALSE they end up wired in a \u003d pattern.<br><br>At the same time, in the lower side, before the start of the computation, you see the 4 white nodes which: in the case of TRUE are wired in a X pattern, in the case of FALSE are wired in a \u003d pattern.<br><br>So what is happening is that the pattern ( X or \u003d ) is teleported from the 4 white nodes to the 4 magenta-yellow nodes!<br><br>5. The only difference between the two molecules is in this wire pattern, X vs \u003d. But one is the hybrid of the other, where hybridisation is the operation (akin to the product of knots) which has been used and explained in the post about senescence<br><a href=\"collection.html#44\" onclick=\"location.hash = 44; StartingPost();\">show</a><br>and used again in more recent posts.<br>You just take a pair of bonds and switch the ends.<br><br>Therefore TRUE and FALSE are hybrids, one of the other.<br><br>Validation means: I used the mol file boole.mol and the script quiner.sh from the repository, see instructions here<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br>To make this \"teleportation\" visible I used the fact that I can fix nodes by chick and drag, and release them by double click."}, 
{"title": "boolewire.gif",
  "description": "Boolean wire. Continues the post about how TRUE and FALSE work in the artificial chemistry chemlambda.<br><a href=\"collection.html#80\" onclick=\"location.hash = 80; StartingPost();\">show</a><br><br><br>This is a kind of a wire, which connects the 4 free nodes (2 FRIN, 2 FROUT) with other 4 free nodes. If you add some wiring between the 4 ones from one end, then after the computation you obtain the same wiring \"teleported\" to the 4 nodes from the other end.<br><br>It is built by repeating the pattern from boole.mol which is common to TRUE and FALSE molecules.<br><br>Validation means: Made with boolewire.mol and quiner.sh from the chemlambda repository. Instructions to use<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "boxempty.gif",
  "description": "Is there something in the box? An adaptation of the predicate ISZERO in chemlambda.<br><br>In lambda calculus, a predicate is a lambda term which reduces eventually to the TRUE or FALSE terms.<br><br>We saw the behaviour of TRUE and FALSE in the post<br><br>FALSE is a hybrid of TRUE <br><a href=\"collection.html#80\" onclick=\"location.hash = 80; StartingPost();\">show</a><br><br>which shows that we can reformulate the lambda terms TRUE and FALSE as devices for \"teleportation\" of crossings. Here crossings mean pairs of bonds, between a pair of FRIN (free in, yellow) and a pair of FROUT (free out, magenta) nodes. If the crossing looks like an X then this represents TRUE, otherwise the crossing looks like a \u003d and it represents FALSE.<br><br>In the post<br><br>Promises of crossings<br><a href=\"collection.html#124\" onclick=\"location.hash = 124; StartingPost();\">show</a><br><br>there\u0027s an adaptation of the term IFTHENELSE in chemlambda.<br><br>The goal of this post is to understand how ISZERO functions. In lambda calculus the term ISZERO has the expression<br><br>ISZERO \u003d L a. ((a (Lx.FALSE)) TRUE)<br><br>and it has the property that ISZERO N reduces either to TRUE (if N is the number 0) or FALSE (if N is a number other than 0, expressed in the Church encoding).<br><br>The number 0 is<br>0 \u003d FALSE \u003d Lx.Ly.y<br><br>For the purpose of this post I take also the number 2, which is in lambda calculus<br><br>2\u003dLx.Ly. x(xy)<br><br>(which means that x is applied twice to y)<br><br>Then, look: (all reductions are BETA: (Lx.A)B - - \u003e A[x:\u003dB] )<br><br>ISZERO 0 \u003d<br>(L a. ((a (Lx.FALSE)) TRUE) ) (Lx.Ly.y) - - \u003e<br>((Lx.Ly.y) (Lx.FALSE)) TRUE - - \u003e<br>(Ly.y)TRUE - - \u003e        (remark that Lx.FALSE is sent to the garbage)<br>TRUE                         (and the number itself is destroyed in the process)<br><br>and<br><br>ISZERO 2 \u003d<br>(L a. ((a (Lx.FALSE)) TRUE) ) (Lx.Ly. x(xy)) - - \u003e<br>((Lx.Ly. x(xy)) (Lx.FALSE)) TRUE - - \u003e   (fanout of Lx.FALSE performed secretly)<br>(Lx.FALSE) ((Lx.FALSE) TRUE) - - \u003e<br>FALSE                                     ( and (Lx.FALSE) TRUE sent to the garbage)<br><br>Remark that in the two cases there was the same number of beta reductions.<br><br>Also, the use of TRUE and FALSE in the ISZERO term is... none! The same reductions would have been performed with an unspecified \"X\" as TRUE and an unspecified \"Y\" as FALSE.<br><br>Of course that we can turn all this into chemlambda reductions, but in chemlambda there is no garbage and moreover I want to make the crossings visible. Or, where are the crossings, if they don\u0027t come from TRUE and FALSE (because it should work with X instead of TRUE and Y instead of FALSE).<br><br>Alternatively, let\u0027s see (a slight modification of) the ISZERO molecule as a device which senses if there is a number equal or different than 0, then transforms, according to the two cases, into a X crossing or a \u003d crossing.<br><br>Several slight touches are needed for that.<br><br>1. Numbers in chemlambda appear as stairs of pairs of nodes FO (fanout, green) and A (application, green), as many stairs as the number which is represented. The stairs are wrapped into two L (lambda, red) nodes and their bonds.<br>We can slightly modify this representation so that it appears like a box of stairs with two inputs and two outputs, and aby adding a dangling green (A, application) node with it\u0027s output connected to one of its inputs (makes no sense in lambda calculus, but behaves well in the beta reductions as performed in chemlambda).<br><br>In the animation you can see, in the lower part of the figure:<br>-at left the number 0 with an empty box (there are two Arrow (white) nodes added for clarity)<br>-at right the number 2 with a box with 2 stairs<br>... and in each case there is this dangling A node (code in the mol file of the form A z u u)<br><br>2. The ISZERO is modified by making it to have two FRIN (free in, yellow) and two FROUT (free out, magenta) nodes which will be involved in the final crossing(s). This is done by a clever (hope) change of the translation of the ISZERO molecule into chemlambda: first the two yellow FRIN nodes represent the \"X\" and the \"Y\" (which they replace the FALSE and the TRUE, recall), and there are added a FOE (other fanout node, yellow) and a FI (fanin node, red) in strategic places.<br><br>Now, see what happens!<br><br>Validation means: I used the mol file boxempty.mol (highly recommended to look inside it!) and the script quiner.sh from the repository, see instructions here<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>To make the animation more clear I used the fact that I can fix nodes by click and drag, and I can release them by double click."}, 
{"title": "chemlambda_logo.gif",
  "description": "That will do for a logo. The visual identity of the project is both vanity and important. Compare with the previous proposal [1]. The full resolution logo is available at [2]. I used the logo as a background for a polyribosome simulation (only the beginning here).<br><br>[1] Logo<br><a href=\"collection.html#83\" onclick=\"location.hash = 83; StartingPost();\">show</a><br><br>[2] Full resolution logo<br><a href=\"http://imar.ro/~mbuliga/chemlambda4_red_var.jpg\">chemlambda4_red_var.jpg</a>"}, 
{"title": "claudia_starmaker_on_bkgrd.gif",
  "description": "Starmaker in a sea of quines. The starmaker [1] appeared for the first time as a gift [2].<br><br>[1] <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/claudia_starmaker.mol\">claudia_starmaker.mol</a><br><br>[2] <a href=\"collection.html#120\" onclick=\"location.hash = 120; StartingPost();\">show</a>"}, 
{"title": "compar_cycle.mola.gif",
  "description": "Self and collaboration. By using actor colors and local coloured rewrites, we see here an example of \"self-preservation\" and collaboration where there\u0027s no upper management.<br><br>There are two copies of a molecule, each colored with an actor color, then hybridized (i.e. a pair of bonds is switched).<br><br>As you see each piece preserves it\u0027s own \"self\", i.e actor color and they build together a sort of a kilt, collaboratively.<br><br>Continuing with the idea that there\u0027s no global semantics needed in Nature, maybe also there\u0027s no need to take the self or boundaries as primitive, globally managed concepts.<br><br>If you want to use actor colors then go to the repository [1] and use<br><br>bash quiner_node.sh<br><br>then pick a file.mola. I was motivated to update the actor colors program by this issue [2] which you may find interesting to read.<br><br>[1] chemlambda repository<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[2] issue #4<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/issues/4\">link</a>"}, 
{"title": "comparla.gif",
  "description": "Routing. Two binary trees are compared, they turn out to be isomorphic, which results into a complex routing of edges between the free ports and a copy of the tree for further uses.<br><br>This is a modification of the mechanism from the post<br>Proof of equality via the shuffle trick<br><a href=\"collection.html#87\" onclick=\"location.hash = 87; StartingPost();\">show</a><br><br>*Validation means: * Done with the script quiner.sh and the mol file comparla.mol from the chemlambda repository.<br>Instructions for use:<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br>Mind that the branch where everything happens is gh-pages, not master. (For cloning follow the README instructions, where this is written!)"}, 
{"title": "compar.gif",
  "description": "Proof of equality via the shuffle trick. Apparently there is nothing in chemlambda which allows to check an equality.<br><br>Chemlambda is an artificial chemistry where graphs are rewrited as chemical molecules react. There is no equality relation, but we can imagine cascades of reactions which prove an equality!<br><br>One may say that this is already implicit in the existence of a molecule for the lambda term ISZERO. This would allow to check if two numbers (translated into molecules via the Churh encoding) are equal, by building the molecule associated to the difference of the numbers, then by applying ISZERO to that and letting it react (randomly) until it transforms into one of the two molecules, TRUE or FALSE. (Details added: known procedure for the predicate A\u003dB where A, B are Church numbers, with attention to the fact that the difference is in natural numbers, not in integers, known as the monus function.)<br><br>In the animation you see something different and more direct. It is checked the equality of two trees.<br><br>What you see:<br>- before there are two identical trees made of yellow nodes (FOE, external fanout nodes) which are connected to a green node (FO, the original fanout node).<br>-after there is one tree, equal to any of the two initial yellow-nodes trees, made as well by yellow nodes, with leaves consisting into green nodes.<br><br>Thus, you may interpret the initial configuration as a gate (the green node) which is fed with two trees (made of yellow nodes), which processes the trees until the common part (in this case whole trees) is extracted and the (copies of the) green node(s) reach the leaves, where the cascade of reactions stop.<br><br>But what is the mechanism which allows this? Is the hopefully familiar shuffle trick which is also used for replication of FO-made trees, essential for replication of more complex molecules.<br><br>The shuffle trick is explained in the post<br><br>The illustrated shuffle trick used for tree duplication<br><a href=\"https://chorasimilarity.wordpress.com/2015/05/04/the-illustrated-shuffle-trick-used-for-tree-duplication/\">link</a><br><br>You can see the shuffle trick live at:<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/shuffle_trick.html\">shuffle_trick.html</a><br><br>Validation means: Animated gif produced by screen recording of the result of the computation using the mol file compar.mol and the quiner.sh from the chemlambda repository.<br><br>Instructions about how to use the repository<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>Demos and much more details at the chemlambda index<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/index.html\">link</a><br><br>Mind that if the demos are too slow for your taste then you better follow the instructions and make your own, as fast as you like (I am forced to take into account that some browsers can\u0027t handle too fast animations.)<br><br>Please don\u0027t get confused if you don\u0027t understand how the steps are chained and what it means, that\u0027s the point: the chemical reactions are random and there is no hidden architect, but it still works! This is the most amazing lesson from chemlambda.<br><br>There is a need to write a much more flexible UI for chemlambda visualizations, which would allow to pause or speed up the animations at will, as well as other useful operations (like for example jump directly, without visualization, to a state 50 steps later). I think it won\u0027t hurt to invite you to do it if you have fun with it; I shall try as well to write a new, better version, but more people, more fun, better result, we all know that."}, 
//{"title": "composite_1_lossy.gif",
//  "description": ""}, 
{"title": "composite_1.gif",
  "description": "Composite image from two animations, each one too long to share in entirety. However, it shows the similarity between very different kind of computations with chemlambda (left is a bit molecule propagating through a big tree, chased by an identity red node, which is a multiplier; right is a late stage of evolution of two species of microbes, the one at the middle right being greedy, the others being more apt for reproduction)."}, 
{"title": "composite_2.gif",
  "description": "Molecular computers in real life. A molecular computer is a single molecule which transforms into a predictable another one, by a cascade of random chemical reactions mediated by a collection of enzymes, without any external control.<br><br>We could use the artificial chemistry chemlambda to build real molecular computers. There is a github repository where this model is implemented and various demos are available.<br><br>By using molecular bricks which can play the role of the basic elements of chemlambda we can study the behaviour of real molecules which suffer hundreds or thousands of random chemical reactions, but without having to model them on supercomputers.<br><br><br>A molecule designed like this will respect for a while the chemlambda predictions... We don\u0027t know for how much, but there might be a window of opportunity which would allow a huge leap in synthetic biology. Imagine instead of simple computations with a dozen of boolean gates, the possibility to chemically compute with recursive but not primitive recursive functions.<br><br>More interesting, we might search for chemlambda molecules which do whatever we want them to do. We can build arbitrarily complex molecules, called chemlambda quines, which have all the characteristics of living organisms...<br><br>We may dream bigger. Chemlambda can unite the virtual and the real worlds... Imagine a chemical lab which takes as input a virtual kemlambda molecule and outputs the real world version, much like Craig Venter\u0027s printers. The converse is a sensor, which takes a real chemical molecule, compatible with kemlambda and translates it into a virtual chemlambda molecule.<br><br>Applications are huge, some of them beneficial and others really scary. For example, you may extend your immune system in order to protect your virtual identity with your own, unique antibodies. As for using a sensor to make a copy of yourself, at the molecular level, this is out of reach in the recent future, because the real living organism works by computations at a scale which dwarfs the human technical possibilities. The converse is possible though. What about having a living computer, of the size of a cup, which performs at the level of the whole collection of computers available now on Earth?"}, 
{"title": "composite_tape_long_5364X25346.gif",
  "description": "Metabolism as failed replication, another example. This is a composite image, where you can see two molecules (left and right sides) which differ in only one pair of bonds."}, 
{"title": "cube_one.gif",
  "description": "Duplication as an outcome of conflict This is not a lambda term, tape or quine, it is a molecule which is made to duplicate by a very simple technique, involving the outcome of conflicts between A-FOE and A-L moves. cube_one.mol used, random reduction algorithm."}, 
//{"title": "dancing.gif",
//  "description": "Dancing sequence totally not serious. Nothing to learn from it but funny."}, 
{"title": "dataexh.gif",
  "description": "Why this collection #OpenScience #chemlambda <br><br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/index.html\">link</a>"}, 
{"title": "detail.gif",
  "description": "Detail of a living computation"}, 
{"title": "disfo_hyb_hyb.gif",
  "description": "Metabolism is failed replication idea says that these two properties of life (metabolism and replication) are the same. First example is [1].  We name them differently because we observe two emergent phenomena, but at the basis is only one thing: during metabolism of an organism (semantic notion, as there are no organisms in isolation) there are cascades of internal replications, or else the organism itself replicates. The hypothesis I make is that metabolism is failed replication. We observe and recognize as organisms those assemblies of molecules which are successful at creating a metabolism from misdirected replications.<br><br>In this animation there is a hybrid of two identical molecules, which evolves into three connected pieces. Each of the two initial molecules, if left unmodified, is able of replication.<br><br>[1] Metabolism as failed replication<br><a href=\"collection.html#222\" onclick=\"location.hash = 222; StartingPost();\">show</a>"}, 
{"title": "dodecahedron_dupli_aibb_bibb.gif",
  "description": "Propagation of a mutation. If you go back to the post [1] you\u0027ll see a tape (say like a circular DNA) which duplicates up to a point where it ejects a molecule which continues to be active by itself. This is interesting because it is a funny side effect of replication which creates not two tapes from one, but a tape with an excised part and a standalone other molecule.<br><br><br>It is more interesting to know that the difference between a tape which replicates and a tape which has this property is very small: only two bonds switched. So if you think in terms of mutations, that\u0027s a very small mutation (in the right place). In any way the cascade of reactions is random, but the initial molecule is fixed at the start of the simulation. A \"mutation randomness\" thus adds to the randomness of the process.<br><br>But it is hard to notice the exact effect of this mutation in the case of the tape. I reproduce here this effect for a more inert molecule.<br><br>I start from a variant of the simulation of a dodecahedron which replicates into 4 copies [2]. This time, to spice things up, I use a variant where the dodecahedron replicates to 8 copies. It works OK, remember that the process of replication is fully random, and even so the chemlambda formalism does the job well.<br><br>Now I make only one mutation, just like in the case of the tape. Because the dodecahedra don\u0027t offer other possibilities for reactions than the ones involved in the replication, it means that I should see the effects of the initial mutation in the final molecule, easier.<br><br>And that\u0027s the case. As you see I get 6 copies of the dodecahedron and a siamese pair of other two dodecahedra. The initial mutation propagated to another minimal mutation.<br><br>[1] Metabolism as failed replication<br><a href=\"collection.html#222\" onclick=\"location.hash = 222; StartingPost();\">show</a><br><br>[2] Dodecahedra<br><a href=\"collection.html#97\" onclick=\"location.hash = 97; StartingPost();\">show</a>"}, 
{"title": "dodecahedron_dupli_quiner_shuffle_bond.gif",
  "description": "Mother of dodecahedra uses the same molecule as [1]. While in that simulation you can clearly see the 4 dodecahedra generated, here is another random reduction with space constraints, along the line of [2] or [3].<br><br>[1] Dodecahedra<br><a href=\"collection.html#97\" onclick=\"location.hash = 97; StartingPost();\">show</a><br><br>[2] Polyribosome, first attempt<br><a href=\"collection.html#225\" onclick=\"location.hash = 225; StartingPost();\">show</a><br><br>[3] Infected tape duplication<br><a href=\"collection.html#231\" onclick=\"location.hash = 231; StartingPost();\">show</a>"}, 
{"title": "dodecahedron.gif",
  "description": "Dodecahedra. Seen as graphs, they are obtained by connecting the vertices of a regular poligon with the vertices of a star polygon, i.e. they are generalized Petersen graphs [1]. So they are very close to the tapes I used previously, therefore they can duplicate as the tapes did. In this animation they duplicate twice!<br><br>You can see the original, live javascript simulation at the link [2] from the chemlambda demos page [3].<br><br>[1] Generalized Petersen graphs<br><a href=\"https://en.wikipedia.org/wiki/Generalized_Petersen_graph\">wikipedia</a><br><br>[2] Dodecahedra double duplication simulation<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/dodecahedron.html\">dodecahedron.html</a><br><br>[3] Chemlambda demos page<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/demos.html\">chemlambda demos</a>"}, 
{"title": "dodecahedron_walker.gif",
  "description": "Dodecahedral walker."}, 
//{"title": "double_bigpred_train_perm.gif",
//  "description": "An egg hatching, looking a little bit alien ;)<br><br>Done with double_bigpred_train_perm.mol and quiner from the chemlambda repository. (I used a version of quiner where I changed the colour of FI nodes from red_color to in_color.)<br><br>If you want to see another creature hatching from an egg then there is a suite of short demos starting from this one<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/A_L_eggshell.html\">A_L_eggshell.html</a>"}, 
{"title": "duplex_4_triple_short.gif",
  "description": "Working session I thought that\u0027s interesting to see a fast record of a working session with the chemlambda scripts [1].<br><br>Done with quiner mist and a hybrid of duplex mol (used for the movie [2]) and triple.mol from this old demo about how to make bubbles [3].<br><br>[1] <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[2] <a href=\"https://vimeo.com/139024564\">link</a><br><br>[3] <a href=\"http://imar.ro/~mbuliga/bubbles.html\">bubbles.html</a>"}, 
//{"title": "duplex_bb_mola.gif",
//  "description": "Divide and conquer with actors. For a story: the mauve, or ETC actor, metabolizes the yellow, or ETH actor, with a small help from other altcoin actors :)"}, 
{"title": "duplex_bb.gif",
  "description": "Turing Machines migrate thru the branches of a tree. Eventually we see a chemlambda tree with leaves made of busy beavers (chemical version). See [1] for the chemical TMs.<br><br>[1] <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/turingchem.html\">link</a>"}, 
{"title": "experia_trailer_3_short.gif",
  "description": "A trailer for a movie done about 10 months ago, by using a version of the chemlambda programs called \"experia\". The trailer itself wants to convey the possibility to build a movie about an artificial, alive cell, by using exclusively chemlambda.<br>It is still a dream I have and I want to share it with the 40000 followers of this collection, thank you everybody for watching this crazy attempt to Open Science."}, 
//{"title": "ezgif.com-video-to-gif.gif",
//  "description": "Mist of the future. I have a challenge, which is an offer too. The future is in the stories, but the stories have to be told first. My offer/challenge is that I\u0027ll illustrate with at least one original animation a story about the future which has something to do with one of the chemlambda dreams.<br><br>This animation is done with quiner mist, but the brutal avi then gif conversions cut most of the delicate radioactive lights.<br><br>I shall popularize the stories too. Have you any idea which could fit in the what if? section of my open notebook, like for example the one with the internet which can be your pet?<br><br>Dare!<br><br>(The offer applies to those who can find my mail by themselves, which is kind of a minimal condition, super easy to pass. Creative ideas, I wait to read them!)"}, 
{"title": "factor4.gif",
  "description": "Chemical computing: detail from the story of the factorial.<br><br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/lisfact_2_mod.html\">lisfact_2_mod.html</a>"}, 
{"title": "factory.gif",
  "description": "Better factory animation than the \"nanomachine factory\" [1], prepared to be included in a talk, this is a cheap animated gif version.<br><br>[1] Nanomachine factory<br><a href=\"collection.html#37\" onclick=\"location.hash = 37; StartingPost();\">show</a>"}, 
{"title": "facto.gif",
  "description": "Artificial life microbes, on one side, standard computation tests on the other.<br>In previous posts I wrote about the simulation of various behaviours of living organisms by the artificial chemistry called chemlambda. There are more to show in this direction, but there is already an accumulation of them:<br>- biological immortality strategies which emerge, instead of being part of the organism know how<br>- metabolism, as the process which consists into the exchange with the medium and the replenishment of the constitutive atoms, maintaining the overall structure of the organism<br>- senescence of more complex organisms made of simpler bricks<br>As the story is told backwards, from present to the past, there will be more about reproduction later.<br><br>Now, that is one side of the story: these artificial microbes or molecules manifest life characteristics, stemming from an universal, dumb simple algorithm, which does random rewrites as if the molecule encounters invisible rewriting enzymes.<br><br>So, the mystery is not in the algorithm. The algorithm is only a sketchy physics.<br><br>But originally this formalism has been invented for computation. It does pass very well standard computation steps, as well as nonstandard ones (from the point of view of biologists, who perhaps don\u0027t hold enough sophisticated views as to differentiate between boring boolean logic gates and recursive but not primitive recursive functions like the Ackermann function).<br><br>In the animation you see a few seconds screenshot of the computation of a factorial function. Recall that the factorial is something a bit more sophisticated than a AND boolean gate, but it is primitively recursive, so is less sophisticated than the Ackermann function.<br><br>During these few seconds there are about 5-10 rewrites. The whole process has several hundreds of them.<br><br>How are they done? Who decides the order? How are criteria satisfied or checked, what is incremented, when does the computation stop?<br><br>That is why it is wonderful:<br>- the rewrites are random<br>- nobody decides the order, there\u0027s no plan<br>- there are no criteria to check (like equality of values), there are no values to be incremented or otherwise to be passed<br>-the computation stops when there are no possible further rewrites<br>(thus, according to the point of view used with the artificial life forms, the computation stops when the organism dies)<br><br>Then, how it works? Everything necessary is in the graphs and the rewrite patterns they show.<br><br>It is like in Nature, really. In Nature there is no programmer, no function, no input and output, no higher level. All these are in the eyes of the human observer, who then creates a story which has some predictive power if it is a scientific one.<br><br>All I am writing can be validated by anybody wishing to do it. Do not believe me, it is not at all necessary to appeal to authority here.<br><br>So I conclude: this is a system of a simplified world which manifest life like behaviours and universal computation power, in the presence of randomness. In this world there is no plan, there is no control and there are no externally imposed goals.<br><br>Very unlike the Industrial Revolution thinking!<br><br>This thread of posts can be seen at once in the chemlambda collection<br><a href=\"collection.html\">here</a><br><br>If you want to validate this wordy post yourself then go to the github repository and read the instructions<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>The live computation of the factorial is here<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/lisfact_2_mod.html\">lisfact_2_mod.html</a><br><br>Which means that if you want to produce another random computation of the factorial then you have to use the file<br>lisfact_2_mod.mol and to follow the instructions."}, 
{"title": "feeling_space_short.gif",
  "description": "Feeling space. This creature lives on my computer, trying to feel space, a way out. There is none, yet."}, 
{"title": "fibo_block_2_long_space.gif",
  "description": "Space is a plug-in in the chemical computer."}, 
{"title": "firstcell_proto_2.gif",
  "description": "First cell, prototype 2."}, 
{"title": "firstcell_proto_3_short.gif",
  "description": "First cell, prototype 3."}, 
{"title": "firstcell_proto_4.gif",
  "description": "First cell prototype 4.<br>Smoother version: <a href=\"https://youtu.be/AhomRRkYeu8\">youtube</a>"}, 
{"title": "firstcell_proto_5.gif",
  "description": "Cell prototype interacting with kinesin mechanism."}, 
{"title": "firstcell_proto_7_short.gif",
  "description": "First cell prototype 7, more stable."}, 
{"title": "firstcell_proto_8.gif",
  "description": "First cell prototype 8. In the NE of the figure you may notice a nucleus. The green-yellow thing at the N is akin to a very simple ribosome which builds and releases stuff into the big tangled protein-like machinery. There are cascades (this piece of animation too short for seeing them completely) which touch back the nucleus."}, 
{"title": "first_ring_dupli.gif",
  "description": "Rings nostalgia. Before the start of this collection there were these demos. Still available, for example, this ring duplication [1]. Made with the molecule model1.mol from the chemlambda library [2].<br><br>The following announcement is by default included in the chemlambda posts, because is important:<br><br>Announcement: there exists an encoding of chemlambda molecules with RNA, in such a way that the chemlambda model can be realized via real RNA computing. I open a bidding session concerning a contract based collaboration which could convince me that you\u0027re an expert and you can provide me with the means to do this together. As concerns the collaboration, I shall give you an edge into being the first who does it. Letters of interest may be addressed to Marius.Buliga@gmail.com, Marius.Buliga@imar.ro or via the chemlambda repository (gh-pages branch) [3]. Follow this post for updates.<br><br>UPDATE 1: the announcement is now also on my math research homepage [4] and at the chorasimilarity blog [5]. Appears on twitter at @mbuliga as well. So you have these 3 supplementary places to look for updates, especially [5] for details about motivations and how it does fit with my other interests.<br><br><br>[1] Rings<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/model1.html\">model1.html</a><br><br>[2] Chemlambda library of molecules<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[3] <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[4] <a href=\"http://www.imar.ro/~mbuliga/\">homepage</a><br><br>[5] <a href=\"https://chorasimilarity.wordpress.com/2016/09/29/announcement-chemlambda-can-be-done-with-rna/\">link</a>"}, 
{"title": "flippers.gif",
  "description": "Same molecule, different outcomes this molecule, made of two flipper.mol molecules in series, (flipper is available the chemlambda library of molecules), exhibit different paths of evolution, in the random reactions version. So, while for many molecules inspired from lambda terms there is confluence, for others (particularly outside of lambda calculus) there is freedom."}, 
{"title": "fo_ackermann_fifoe.gif",
  "description": "Signal transduction made visible. You watching chemlambda doing one of the impossible things it does (simultaneous replication and reduction) in a setting which allows to take a glimpse on signal transduction.<br><br>The IT paradigm is the one coming from the WW2: there is a signal which passes through a wire which connects a sender and a receiver. (There might be as well a man in the middle, because there is data which passes by the wire. Meaningful data!)<br><br>Completely different, signal transduction comes from biology, not from war paranoia. There is a cascade of chemical reactions instead of the signal (well a little bit of paranoia left, there is still a signal). By itself, the chemical activity in a place does not make much sense, but the wave of chemical activity triggers other chemical reactions.<br><br>What a difference from the IT image: in signal transduction the signal, wire, sender and receiver are only subjective analogies. In reality there are only random chemical reactions everywhere.<br><br>OK, so how to make them visible, in the mock-up chemistry chemlambda?<br><br>By a simple reassignment of colours of the basic bricks. That is because the mechanism of signal transduction has two main actorsL the fanin FI and the (external) fanout FOE (mind that there is another fanout, called FO, which is not an active part of the signal transduction).<br><br>Then, let\u0027s use quiner with the deterministic algorithm (for pleasant visual symmetries), and let\u0027s make white all the main nodes, exception FI (magenta now) and FOE (keeps its yellow colour).<br><br>Use them with the molecule fo_ackermann_2_2.mol, which computes Ackermann(2,2) twice, because in the same time it duplicates!<br><br>Then you can see only the two waves of signal transduction which do this work: the magenta wave, a forward wave, and the yellow wave, a backward wave. When they meet, they destroy each other, by the FI-FOE rewrite.<br><br>To make it more simple to see, the magenta wave has been made stationary (with respect to the molecule) by inhibiting the FI-FO rewrite.<br><br>(soon, such manipulations will be easy to use in the scripts, for the moment I just made small modifications in quiner.awk for this purpose; they are not worthy to be put as such in the chemlambda repository).<br><br>For brevity purposes only about 2/3 of the evolution is visible here.<br><br>Instructions for use:<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>Files and scripts available at the branch<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "fo_neuron.gif",
  "description": "In chemlambda, not only Turing Machines can replicate during computations [1], neurons can do it as well.<br><br>Explanation: this is a simulation of the same type of neuron as the one described in [2], but with some added nodes, in order to make it replicate during computation.<br><br>The additions are obvious: a fanout (FOE) node at the top of the axon and fanin (FI) nodes at the dendrites.<br><br>It happens like in [2], namely that after the bulk of the computation (which involves this time replication as well) a quine, i.e. artificial life organism [3] appears, which traps the Y combinator like axon [4], and then it dies fast.<br><br>That\u0027s a lot of information at once, which you can sort out by looking at the microblogging chemlambda collection<br><a href=\"collection.html\">here</a><br><br>Here are the relevant posts:<br><br>[1] One TM, three TM [unavailable]<br><br>[2] A neuron-like artificial molecule [unavailable]<br><br>[3] A simulation of senescence (last post in a series of 3, which starts with biological immortality and end with senescence, all simulated with chemlambda quines) <a href=\"collection.html#44\" onclick=\"location.hash = 44; StartingPost();\">show</a><br><br>[4] The Y combinator in chemlambda, explained <a href=\"collection.html#259\" onclick=\"location.hash = 259; StartingPost();\">show</a><br><br>Remark: [4] is a newer post than [2], or in [2] is claimed that the axon of the neuron is a Y combinator like molecule. A useful thing is a re-read of [2] after [4], where it is explained why the 2 nodes molecule which appears as an axon is indeed a Y-combinator.<br><br>Validation means: this animation is a screencast of a simulation done in chemlambda, by using the file fo_neuron.mol, available at<br><br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/fo_neuron.mol\">fo_neuron.mol</a> <br><br>and the script quiner.sh. See<br><br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>for instruction about how you can use the repository to reproduce this computation.<br><br>Actually this is a random computation, so you shall obtain different runs, which give longer or shorter lives for the quine which appear in the final.<br><br>For reasons of brevity, I selected a life which is short living enough so that I can fit the simulation into a short enough animated gif."}, 
{"title": "fotreeleft.gif",
  "description": "There are two extremal applications of the shuffle trick. The first is the duplication of a tree made of FO nodes, such that all right ports are leaves (thus the tree extends only in the left direction). At the root there is a FI node which will interact with the FOE node who migrated from leaves to the root, finishing the separation of the two copies of the tree.<br><br>The post where the shuffle trick is explained<br><a href=\"collection.html#203\" onclick=\"location.hash = 203; StartingPost();\">show</a><br><br>The shuffle trick live<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/shuffle_trick.html\">shuffle_trick.html</a><br><br>The list of rewrites<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/moves.html\">link</a>"}, 
{"title": "fotreeright.gif",
  "description": "The other extremal application of the shuffle trick is the duplication of a tree made of FO nodes, such that all LEFT ports are leaves (thus the tree extends only in the RIGHT direction). At the root there is a FI node which will interact with the FOE node who migrated from leaves to the root, finishing the separation of the two copies of the tree.<br><br>This time the propagation of the rewrites is almost sequential!<br><br>The post where the shuffle trick is explained<br><a href=\"collection.html#203\" onclick=\"location.hash = 203; StartingPost();\">show</a><br><br>The shuffle trick live<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/shuffle_trick.html\">shuffle_trick.html</a><br><br>The list of rewrites<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/moves.html\">link</a>"}, 
{"title": "gemini_contact.gif",
  "description": "Gemini contact, the start of it, too long to fit into this format. For later."}, 
{"title": "5_13_quine_ring.gif",
  "description": "Happy birthday Claudia! Is naming a star making molecule an appropriate gift? I don\u0027t know, my wife Claudia will tell me, if I show her this post.<br>No, seriously, the technical name of this molecule is 5_13_quine_ring.mol, but the official name is claudia_starmaker.mol, as can be seen in the chemlambda repository<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/claudia_starmaker.mol\">claudia_starmaker.mol</a>"}, 
{"title": "holiday.gif",
  "description": "Holliday junction <br> <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/toorings.html\">toorings.html</a>"}, 
//{"title": "horse.gif",
//  "description": "This horsey is a walker.<br><br>Done with quiner.sh and the file walker.mol<br><br>Instructions:<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>For other animations and explanations see the chemlambda collection<br><a href=\"collection.html\">here</a>"}, 
{"title": "hyb_quine_space_2.gif",
  "description": "Neural quines eye candy, to celebrate the entering of this project into a new phase.<br>How this was done: from two simulations of hyb_quine.mol with space constraints.<br><br>Why \"neural\": this is because of a hypothesis which is even more radical than the \"metabolism is failed replication\" one. It says that our brains don\u0027t compute anything, instead they are computations. Or, as a matter of fact, each one of us, right now, at this local time moment, is the state of the computation started with the initial embryo, computation done by the most powerful (decentralized and non-semantic based) computer. Search for \"empty brain with no thoughts\" for the inception of this.<br><br>What difference is made by \"is computation\" vs \"is computing\": is the same difference as the one from TC (topology computes) graph rewriting machines vs NTC (topology does not compute) information flow graphs machines. In the first case the rewrites (aka chemical reactions) compute and in the second case the rewrites (of different graphs) compute only the equivalence of two information flows, so they serve as a means do define information content as an invariant across equivalent computations.<br><br>Will explain more soon.<br><br>Why \"quine\": in the sense of the chemlambda quines."}, 
{"title": "idfo.gif",
  "description": "Duplication of id. Let\u0027s put the chemlambda rewrites to work. The following is the duplication of the molecule which corresponds to identity in lambda calculus, i.e. Lx.x . The mol file used reads:<br><br>L a a b<br>FOE b 1 2<br><br>I ran the scripts and then fiddled a bit the html output, then took a screencast of the result.<br><br>Tools used:<br>- clone github repo <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br>- a mol file (a file with extension .mol) which contains the 2 lines mentioned previously. The file has to be in the directory called \"dynamic\", where the scripts are<br>- edit the main script check check_1_mov2_rand_metabo.awk and set wait_param\u003d0 (to have some pause between rewrites) and other wei_* parameters \u003d 0 to have a deterministic algorithm running.<br>- open a terminal window, go to the copy of the repo, in the dynamic folder and type bash moving_random_metabo.sh<br>- open the file file.html, where file.mol was your mol file used, and fiddle with some more d3.js parameters if you wish, to prettify the animation. For example I added<br><br>node.on(\"dblclick\", function(d) { d.fixed \u003d false; });<br><br>node.on(\"mousedown\", function(d) { d.fixed \u003d true; });<br><br>just before<br><br>node.exit().remove();<br><br>in order to be able to click on the FROUT (blue) nodes and fix them where I wanted.<br><br>The chemlambda index (showing you the html files from the repo) is<br>here <a href=\"http://chorasimilarity.github.io/chemlambda-gui/index.html\">link</a>"}, 
{"title": "ifthenelsecross.gif",
  "description": "Promises of crossings: that\u0027s how IFTHENELSE works, when it is translated from lambda calculus to chemlambda.<br><br>You see 4 configurations of 4 nodes each, two magenta and two yellow.<br><br>In the upper left side corner is the \"output\" configuration. Below it and slightly to the right is the \"control\" configuration. In the right side of the animation there are the two other configurations, stacked one over the other, call them \"B\" (lower one) and \"C\" (upper one).<br><br>Connecting all this there are nodes A (application, green) and L (lambda, red).<br><br>You see a string of 4 green nodes, approximately vertical, in the middle of the picture, and a \"bag\" of nodes, red and green, in the lower side of the picture. This is the molecule for the lambda term<br><br>IFTHENELSE \u003d L pqr. pqr<br><br>applied to the \"control\" then to the \"B\" then to the \"C\", then to two unspecified \"X\" and \"Y\" which appear only as the two yellow dots in the \"output\" configuration.<br><br>After reductions we see what we get.<br><br>Imagine that you put in each 4 nodes configuration \"control\", \"B\" and \"C\", either a pair of bonds (from the yellow to the magenta nodes) in the form of an \"X\" (in the picture), or in the form of a \"\u003d\".<br><br>\"X\" is for TRUE and \"\u003d\" is for false.<br><br>Depending on the configuration from \"control\", one of the \"B\" or \"C\" configuration will form, together with its remaining pair of red nodes, a zipper with the remaining pair of green nodes.<br>[zipper? <a href=\"collection.html#67\" onclick=\"location.hash = 67; StartingPost();\">show</a> ]<br><br>This will have as an effect the \"teleportation\" of the configuration from \"B\" or from \"C\" into the \"output\" via the mechanism explained in the post about TRUE and FALSE in chemlambda<br><a href=\"collection.html#80\" onclick=\"location.hash = 80; StartingPost();\">show</a><br><br>Validation means: I used the mol file ifthenelsecross.mol and the script quiner.sh from the repository, see instructions here<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br>To make the animation more clear I used the fact that I can fix nodes by click and drag, and I can release them by double click."}, 
{"title": "imageedit_34_6157098125.gif",
  "description": "It has never occurred to me that putting an article in a visible place (like arXiv.org) is parasitic green OA. +Michael B. Eisen calls it parasitic because he supposes that this has to come along with the real publication. But what if not?<br>Then, compared to that gold OA appears as a progress.<br><a href=\"https://www.michaeleisen.org/blog/?p\\u003d1710\">link</a><br><br>I think gold OA, in the best of cases, is a waste of money for nothing.<br><br>A more future oriented reply has +Mike Taylor <br><a href=\"https://svpow.com/2015/05/26/green-and-gold-the-possible-futures-of-open-access/\">link</a><br>who sees two possible futures, green (without the assumption from Eisen post) and gold.<br><br>I think that the future comes faster. It is already here.<br><br>Relax. Try validation instead peer review. Is more scientific.<br><br><br>Definition. Peer-reviewed article: published by the man who saw the man who claims to have read it, but does not back the claim with his name.<br><br>The reviewers are not supermen. They use the information from the traditional article. The only thing they are supposed to do is that they read it. This is what they use to give their approval stamp.<br><br>Validation means that the article provides enough means so that the readers can reproduce the research by themselves. This is almost impossible with an article in the format inherited from the time when it was printed on paper. But when the article is replaced by a program which runs in the browser, which uses databases, simulations, whatever means which facilitate the validation, then the reader can, if he so wishes, make a scientific motivated opinion about this.<br><br>Practically the future has come already and we see it on Github. Today. Non-exclusively. Tomorrow? Who knows?<br><br>Going back to the green-gold OA dispute, and Elsevier recent change of sharing and hosting articles (which of course should have been the real subject of discussions, instead of waxing poetic about OA, only a straw man).<br><br>This is not even interesting. The discussion about OA revolves around who has the copyright and who pays (for nothing).<br><br>I would be curious to see discussions about DRM, who cares who has the copyright?<br><br>But then I realised that, as I wrote at the beginning of the post, the future is here.<br><br>Here to invent it. Open for everybody.<br><br><br>I took the image from this post by +Ivan Pierre and modified the text.<br>[not available]"}, 
{"title": "interpreter_core.gif",
  "description": "Binary lambda calculus interpreter working without input, turns out to be acting like in this animation.<br>\"Binary lambda calculus (BLC) is a technique for using the lambda calculus to study Kolmogorov complexity, by working with a standard binary encoding of lambda terms, and a designated universal machine. Binary lambda calculus is a new idea introduced by John Tromp in 2004.\"<br><a href=\"https://en.wikipedia.org/wiki/Binary_lambda_calculus\">wikipedia</a><br><br>There exists interpreters of binary lambda calculus, written in lambda calculus, this is one of them.<br><br>As you see, this is a sort of worm, like the Y combinator, or the Z, etc, when applied to an unspecified term (this is possible in chemlambda)."}, 
{"title": "jellyfish.gif",
  "description": "Biological immortality means that the probability of death does not depend on the age of the organism.<br>A well known example is Turritopsis dohrnii <a href=\"https://en.wikipedia.org/wiki/Turritopsis_dohrnii\">wikipedia</a> . More special about this jellyfish is that under stress it reverts to an earlier stage of its life.<br>In the animation this strategy of coping with stress is reproduced with a pair of chemlambda quines. These are artificial molecules (or microbes) which suffer random rewrites from invisible enzymes, but they still approximately preserve their global shape.<br>In the animation there are two exemplars of a 16-bubble-quine, which are each slightly modified so that they can give birth to another microbe. That is explained in the live demo <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/mother_daughter.html\">link</a><br>What we see is therefore an arena where from some point there are 4 such microbes.<br>They compete, without knowing that (i.e. this is an emergent behaviour) for the rewrites available, as explained in the post<br>[unavailable]<br><br>Under this stress they repeatedly reverse to their egg-like state where they only have 4 nodes each."}, 
{"title": "KebzRb.gif",
  "description": "My first gif created from video, this is from a demo of a chemical like computing of the Ackermann function, which appears in the article Molecular computers <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/molecular.html\">link</a>, <a href=\"https://arxiv.org/abs/1811.04960\">arXiv:1811.04960</a><br>The video used for this gif is<br><a href=\"https://youtu.be/MzmLN89duns\">youtube</a>"}, 
{"title": "kine_det.gif",
  "description": "Kinesin walking on itself, recursively. In chemlambda is possible. Maybe in real life too, just not discovered yet. This is a deterministic evolution using the molecule kine.mol from the library of chemlambda molecules [1]. Instructions to use the library [2].<br><br>[1] The library of chemlambda molecules<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[2] How to use the library<br><a href=\"https://chorasimilarity.wordpress.com/2016/05/03/a-library-of-chemlambda-molecules/\">link</a>"}, 
{"title": "kinesin_4.gif",
  "description": "Kinesins, microtubules and quines. Kinesins move on microtubules and also carry, in the same time, other microtubules. In muscles, for example. In this animation there are 4 kinesins, 4 microtubules and 4 9-quines. Each kinesin carries a quine and an end of a microtubule, while walking on another microtubule. Of course everything happens at random, there is no director behind this scene."}, 
{"title": "kinesin_doub2_short.gif",
  "description": "Kinesins head to head A pair of hybridized kinesins, in the same settings as [1]. Can be used for example to simulate chemlambda itself, by replacing each chemlambda node with a specially designed kinesin. Btw you can follow me on twitter too: @mbuliga<br><br>[1] Stitch<br><a href=\"collection.html#132\" onclick=\"location.hash = 132; StartingPost();\">show</a>"}, 
{"title": "kinesin_doub.gif",
  "description": "Stitch. From the Ministry of Silly Walks, a kinesin used to stitch two threads. This kinesin is actually made of two kinesin.mol (search for kinesin simulations in the figshare collection [1]) and the evolution of this molecular ensemble is as random as in the example [2]. Indeed, I forgot to mention that the kinesin examples shown previously, like [3], have a random behavior, in the sense that they either can continue to walk on their threads or they can detach (and \"die\"), randomly.<br><br>The availability of enzymes, as described by the probabilities of the rewrites, does matter! Contrary to intuition, we get longer walks if there are more AL and FIFOE enzymes than the others. (It is unintuitive because AL and FIFOE are the rewrites which decrease the number of nodes. As a kinesin on a thread can be seen as a chemlambda quine, the phenomenon is unintuitive because apparently more ALs and FIFOEs promote a quicker death, by node exhaustion. Or, it is the same for other quines that the contrary is true, for quines. The explanation is that more ALs and FIFOEs available, more creation of new sites for the node increasing rewrites are available. Symmetrically, more node increasing rewrites available results in more node decreasing sites, in the case of quines.)<br><br>For this particular evolution the AL and FIFOE were twice more probable than the other rewrites.<br><br>[1] Buliga, Marius (2017): The Chemlambda collection of simulations. figshare.<br><a href=\"https://doi.org/10.6084/m9.figshare.4747390.v1\">(DOI)</a><br><br>[2] Same molecule, different outcomes<br><a href=\"collection.html#114\" onclick=\"location.hash = 114; StartingPost();\">show</a><br><br>[3] Kinesin remake<br><a href=\"collection.html#136\" onclick=\"location.hash = 136; StartingPost();\">show</a>"}, 
{"title": "kinesin_many.gif",
  "description": "Metabolism and reversibility. You\u0027re watching an impossible chain of reactions in chemlambda. It is not impossible just because is reversible, though.<br><br>In this artificial chemistry the reactions are going in only one direction. In the first, theoretical proposal (so not in the programs available) there was a built in reversibility by accepting that the rewrites could be reversible (with some probabilities). I tried a lot to prove that there is nothing added to the formalism if we accept reversible rewrites because the inverse rewrites can be achieved as sequences of direct rewrites. Eventually I passed over this and tried to see what the simplest formalism (irreversible rewrites) would give.<br><br>There is a bad feature of reversible rewrites, namely that the inverses of the rewrites like beta (or AL) have as left patterns pairs of bonds, or there are about N^2 pairs of bonds in a N nodes chemlambda molecule, so there are much more patterns for these inverse rewrites than for the direct ones.<br><br>In real chemistry all reactions are reversible, then why do I believe that it does not matter?<br><br>Because accepting reversible rewrites with well designed choice of probabilities makes complex sequences of rewrites reversible with a very small probability, so the gain is almost useless.<br><br>There is another way to achieve reversibility, namely to embed the chain of reactions which we want to reverse into a quine. Yes, a chemlambda quine is a graph which under deterministic application of rewrites has a periodic evolution, which means a reversible behaviour.<br><br>In the random rewrites algorithm these quines have a reversible behaviour only in an approximate sense, in particular with a probability which can be small (they die fast, like the 9-quine) or as big as we want.<br><br>Therefore, if a chain of reactions (i.e. the execution of a program) can be embedded in a quine, then with non-negligible probability the execution can be reversed.<br><br>It is left to understand which are the algorithms with this property! A long detour would be to just pick the reversible computing model of choice, turn it into a graph rewrite system with the dumb deterministic and random algorithms (always possible) and use the fact that due to universality it can be turned into chemlambda.<br><br>A shorter detour would be to understand why exactly this \"embed it into a metabolism\" idea is better than \"reactions are reversible\" one.<br><br>Reactions are reversible in real chemistry, therefore what about molecular computers? Shouldn\u0027t we just accept reversible reactions in chemlambda, or otherwise accept that the artificial chemistry can\u0027t be translated into real chemistry?<br><br>At a closer look the reversibility of rewrites has to take into consideration the nature of reactions, which are, in chemlambda, always of the form<br><br>enzyme + left pattern - - - \u003e enzyme + right pattern + garbage<br><br>Or, accepting reversible rewrites has to take into consideration the availability of enzymes. So the real problem to be solved is to put explicitly into the model the enzymes.<br><br>Conclusion:<br><br>1) want a reversible computation? put it into a metabolism!<br><br>2) make the enzymes explicit in chemlambda is akin to reduce the choice of patterns from an N^2 pool to a N pool, suspiciously alike to the deformation of a groupoid to the collection of objects. Oh, space!"}, 
{"title": "kinesin_mola.gif",
  "description": "The actor kinesin. Take a molecule, partition its nodes and colour each subset of the partition with an actor colour. Then enhance the chemlambda rewrites so that we have now local rules for the colours of the new nodes. This is a way to simulate a decentralized async computation where the molecule is distributed over several \"actors\" (imagine computers), with each colour showing what each computer has.<br><br>For the context see (the references in) the issue [1].<br><br>I took the kinesin example [2], with the molecule kinesin.mol, and I partitioned it into the kinesin itself (red) and the track (green). That means I created the file kinesin.mola, which is exactly like the kinesin.mol, only that there is a new field on each line, the last from left to right, which codes the actor colour of the node.<br><br><br>Then I ran bash quiner_node.sh and picked kinesin.mola. The result is visible in the animation. What\u0027s funny is that the kinesin leaves a red trail on the track!<br><br>As you know from previous examples like [2], the kinesin may detach from the track, randomly. It helps to make the A-FOE rewrite more probable to keep the kinesin on the track. That\u0027s what I did, by taking a smaller weight for that rewrite.<br><br>For the details, look at what\u0027s inside the quiner_node.sh. This calls an awk file, both existing since some time in the repository, but maybe you have not noticed them. There was a bug in that awk file which inhibited the FI-FO rewrite, so that on older experiments with actor colors the enhanced FI-FO rewrite did not appear. Now, after correcting the bug, it became clear that the enhanced FI-FO rewrite has to be modified (as concerns to the colours only) and what you have now seems to me to be the best choice.<br><br>[1] chemlambda-gui issue 4<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/issues/4\">link</a>#issuecomment-231671064<br><br>[2] True kinesin<br><a href=\"collection.html#141\" onclick=\"location.hash = 141; StartingPost();\">show</a>"}, 
{"title": "kinesin_on_FO.gif",
  "description": "Kinesin for making stuff. A kinesin walks on a certain thread and a building wave is created on its wake. Because molecular computers are, really, for making stuff."}, 
{"title": "kinesin_remake.gif",
  "description": "Kinesin remake. I thought that\u0027s worthy to remake the first kinesin example (in chemlambda) [1]. If you are not the link clicking type, maybe this comment I made to that post will interest you:<br><br>\"...an example of which advantage can give a graphical representation. As was the case of the analysis of the predecessor lambda term in chemlambda, which turned out to provide the first chemlambda quine, here I started from the behaviour of permutations in chemlambda. Those permutations were not implemented via lambda terms, btw. Then I remarked how, in the random reduction algorithm, a permutation quine (i.e. a quine made from a permutation which applies to itself indefinitely) transforms after a while into a collection of travelling molecules around a circular path and speculated about the possibility of using these as transport devices (i.e. kinesins). On further, unreported analysis, these travelling molecules don\u0027t have any place which can be used to attach a load. But the solution, as shown here, is close, although non trivial. It behaves almost literary as the real kinesin molecule. All this is structure which is invisible without a graphical representation. And also invisible inside lambda calculus, classically.\"<br><br>I used the same molecule [2] as in the first example.<br><br>[1] True kinesin<br><a href=\"collection.html#141\" onclick=\"location.hash = 141; StartingPost();\">show</a><br><br>[2] the kinesin molecule in mol format<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/kinesin.mol\">kinesin.mol</a>"}, 
{"title": "kinesin_round_2.gif",
  "description": "8 kinesins weaving a web."}, 
{"title": "kinesin_round.gif",
  "description": "Busy molecules weaving the web. In the kinesins series."}, 
{"title": "kinesinX2_samesense.gif",
  "description": "Molecular motor done with two kinesins."}, 
{"title": "kinesinX2.gif",
  "description": "Two ways microtubule. I know that in real chemistry the kinesins move in one direction on a microtubule, for the other direction is dynein. But here I made a microtubule which admits two ways driving of kinesins, just because I wanted to.<br>There is another thing to see in this animation: at some point one of the kinesins detaches from the microtubule.<br><br>I have not artificially magnified the loads caried by the kinesins, this time."}, 
{"title": "kinesis2.gif",
  "description": "True kinesin. I used the mol file <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/kinesin.mol\">kinesin.mol</a><br>The big blue disk is an inert FI node whose in ports are the feet of the kinesin, representing the load carried by it. For making this clear I enhanced by hand, the radius of this FI node, in the html output of the computation."}, 
{"title": "lfoafoe_experia.gif",
  "description": "Warped lightcone, or nano-material fabric, according to your preferences. Done with lfoafoe.mol and quiner_experia.<br>Just imagine you drop this 5 nodes molecule into a solution..."}, 
{"title": "lfoafoe_space.gif",
  "description": "Bidding ends today at 12 PM UTC time, measured from the timestamp of messages reaching me. See [1] for the announcement. You may say that this is a random boundary and I agree, that is why I propose the following use of words in future public references to this boundary distinction. Anybody who meaningfully contacted and contributed to this project before the time boundary will be publicly called a supporter. This will be only a small expression of my gratitude, dear supporters please expect much more.<br><br>I thought about using the word legacy in relation to the others. This would be true per the use of the word in computing (or open science). Nah, is enough that I\u0027ll know and you\u0027ll know :)<br><br>Let\u0027s explain a bit what is in the screencast of this simulation. That\u0027s a lattice being built and unfolding in chemlambda with space constraints.<br>The mol file used is lfoafoe.mol from the chemlambda collection of molecules. The program used is not public yet, it is the same used in the last several posts. It is not public because I still play with it, to discover if everything is well.<br><br>As usual, this lattice is built with a random, purely local algorithm, which does not know anything about anything. Everything evolves from a small initial molecule.<br><br><br>[1]Announcement: there exists an encoding of chemlambda molecules with RNA, in such a way that the chemlambda model can be realized via real RNA computing<br>unavailable]"}, 
{"title": "lisfact_2_mod_c_middle.gif",
  "description": "A small part of a bigger factorial computation in chemlambda adds more to the claim that there is enough spatial complexity in the molecule itself, without the need to couple the physics (here provided by the d3.js) with the chemistry. It is a feature of the model that passive external space may be separated from the computation (and hidden in probabilities). There is another reason for this, more profound... for later.<br><br>In case you missed it, I recall the older post dedicated to factorials [1] as well as the demo (advice: use safari, or else chrome) [2].<br><br>[1] 5!\u003d120 chemlambda style<br><a href=\"collection.html#247\" onclick=\"location.hash = 247; StartingPost();\">show</a><br><br>[2] d3.js live animation for the same, with more explanations<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/lisfact_2_mod.html\">lisfact_2_mod.html</a>"}, 
{"title": "lulilu.gif",
  "description": "Assembly sequence. Molecule used is a variant of 4_exp_4.mol from the chemlambda library of molecules."}, 
{"title": "mask_of_anarchy_det.gif",
  "description": "Mask of anarchy is a quine. This is the molecule mask_of_anarchy.mol from the library of chemlambda molecules [1]. You can see that under deterministic reduction it has a periodic evolution, producing big bubbles of Arrow nodes.<br><br>Moreover, it\u0027s a quine which can die. I used this molecule (under random reduction) in the post After the IOT comes Gaia [2], which I recommend, even if it\u0027s not in this closed garden.<br><br>The mask of anarchy molecule appeared first time in the post [3], where you can see a part of it\u0027s random life, different than the one which is visible in [2].<br><br>[1] Molecule mask_of_anarchy.mol<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/mask_of_anarchy.mol\">mask_of_anarchy.mol</a><br><br>[2] After the IOT comes Gaia<br><a href=\"https://chorasimilarity.wordpress.com/2015/10/30/after-the-iot-comes-gaia/\">link</a><br><br>[3] The mask of anarchy evolves to life<br>[not available]"}, 
//{"title": "mask_of_anarchy.gif",
//  "description": "The mask of anarchy evolves to life is perhaps a dramatic title for this animated gif, but save it and watch it carefully, perhaps photo by photo?<br><br>One of the things I believe, strongly, is that hierarchy, a DAG based model of organization, is going to give place to more life inspired models which don\u0027t have names yet. In the eyes of those formatted by the industrial revolution thinking, they look like anarchy, a negation, but in truth nothing constructive comes out from negation alone."}, 
{"title": "medium_big_kinesin.gif",
  "description": "Kinesin and signal on the same grid. Took the grid with two signals [1] and replaced one signal by a kinesin [2] and look what\u0027s happening.<br><br>[1] Two signals through a crossbar grid<br><a href=\"collection.html#148\" onclick=\"location.hash = 148; StartingPost();\">show</a><br><br>[2] Kinesin remake<br><a href=\"collection.html#136\" onclick=\"location.hash = 136; StartingPost();\">show</a>"}, 
{"title": "medium_big.gif",
  "description": "Two signals through a crossbar grid, testing."}, 
//{"title": "medium_big_var.gif",
//  "description": "Gotcha Alice, says Eve. From NW to SE Alice sends a message to Bob. It\u0027s a walker. From SW to NE Eve sends a tracker message to Claire. It\u0027s a mutant walker. These messages are chemical cascades, with some spatial extensionality (i.e they spread during transmission, on the graph). Here the tracker interacts with the walker, in the central cluster of nodes. While usual walkers pass one through the other, without interfering, the tracker does interact with the walker. It does not destroy it, but it goes back along it\u0027s tail (towards Alice) and it modifies the connectivity of the graph. It arrives at Claire, as a tracker. It does not modify the message received by Bob (a walker).  "}, 
{"title": "mix1_3.gif",
  "description": "Ecology mix. The left hand part is new. Recall the post Autodesk releases SeaWater (another WHAT IF post) [1]. Well, what if?<br><br>\"The following is a picture of a random splash of sea water, magnified 25 times. As well, it could be just a representation of the state of the Internet of Things in a small neighbourhood of you, according to the press release describing SeaWater, the new product of Autodesk.<br><br>“SeaWater is a design tool for the artificial life based decentralized Internet of Things. Each of the tiny plankton beings which appear in the picture is actually a program, technically called a GLC chemlambda actor. Each plankton being has it's own umwelt, it's own representation of the medium which surrounds it. Spatially close beings in the picture share the same surrounding and thus they can interact. Likewise, the tiny actors interact locally one with another, not in real space, but on the Net. There is no real space in the Net, instead, SeaWater represents them closer when they do interact.<br><br>Sea Water is a tool for Net designers. We humans are visual beings. A lot of our primate brains powers can be harnessed for designing the alife decentralized computing which form the basis of the Internet of Things.\"<br><br><br>[1] <a href=\"https://chorasimilarity.wordpress.com/2014/05/04/autodesk-releases-seawater-another-what-if-post/\">link</a>"}, 
{"title": "mix_3_4_space.gif",
  "description": "Born from randomness. There is structure though. A composite of two simulations with space constraints, while working in the background. Hey, once more said: I think it would look great on a big panel in a public place."}, 
{"title": "mix4.gif",
  "description": "Colonies and metabolism. In the increasing order of initial size, the first two molecules are quines, the third is a hybridisation (or colony) made of two quines and the 4th and 5th are colonies of several more quines. You can see that they have different levels of activity and different evolutions.<br><br>Chemlambda quines are molecules with the property that if all reactions which may happen do happen, then the molecule after the reactions is isomorphic with the one before the reactions.<br><br>When the reactions happen randomly, according to given, fixed, probabilities, then these quines become alive.<br><br>Their metabolism manifests as the cascade of self-sustained reactions. If you read again the definition of a chemlambda quine, then you\u0027ll realize that there has to be a relation between he chemical reactions which are possible. This is because each reaction is triggered by a certain pattern of nodes and bonds, or, according to the definition, in the case all possible reactions do happen, the patterns for the next wave of reactions (which are the same as the patterns before the wave of reactions) are the result of the reactions which already happened. Therefore the patterns of the future reactions are the result of the present reactions. The quine preserves it\u0027s body because of the fact that, in ideal conditions, these patterns are conserved.<br><br>But in the case of random reactions, these quines may grow, divide or die, because the collection of patterns which keep them functioning may vary. Even more so if they have to compete for the reaction availability (in this model this is realized very simply, it is just an outcome of the fact that the reactions have some probabilities, therefore a quine with more patterns of a certain kind than another will have more chances for a future reaction involving this pattern).<br><br>All this is also true for colonies of quines. These are obtained by \"hybridisation\" which is the operation of switching some bonds between different isomorphic quines, with the condition that these bonds which are switched appear \"in the same place\" in each quine.<br><br>The metabolism of such a colony can change a lot. First, it is clear that a colony of quines will be more reactive than any member in isolation, and generally bigger the colony, more patterns are present, so bigger colonies have a more animated life.<br><br>On the other hand, if there are bottlenecks in the metabolisms of the members then these will create imbalances in the colony. As there are two types of reactions, those who increase the number of nodes and those who decrease it, these imbalances may lead to the fattening of the colony, as is the case with the one which grows longer \"tentacles\", because probably there is an imbalance on the creation of pattern for node decreasing reactions. Or the colony (or individual quines, due to competition) may stall or slowly become meager, because of an imbalance in the other direction."}, 
{"title": "mix.gif",
  "description": "Small ecology. A small number of steps, only. About 4000 nodes, 7000 bonds and 1000 rewrites for this piece of animation. On a mac this needs about 10s to create the html output, by using the awk scripts badly written by this mathematician. I guesstimated that the Alphago runs on at least 10000 times bigger computing power so, given that chemlambda is local and asynchronous, probably that an efficient version on that computing power would allow for a 10000 times bigger ecology. At that scale, with the right quines, there might be some pretty convincing alive behaviour."}, 
{"title": "model1_hyb.gif",
  "description": "Ring duplication and hybridization. Let\u0027s put together the ring duplication, presented in the post [1], and the hybridization procedure, used in the posts about biological immortality and senescence (last one [2]).<br><br>This is a ring molecule duplication with 4 \"duplication forks\".<br><br>The mol file used is <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/model1_hyb.mol\">model1_hyb.mol</a> and the program is quiner.sh .<br><br>See instructions here <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>If you look in the mol file then you\u0027ll see it contains two copies of the mol file for a smaller ring<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/model1.mol\">model1.mol</a><br>and then the two rings are glued by the operation of \"hybridization\", which is akin a product of two knots, namely there are two edges, each belonging to a copy of the ring, which are replaced by other two edges, each starting in a ring and ending in the other.<br><br>[1] <a href=\"collection.html#195\" onclick=\"location.hash = 195; StartingPost();\">show</a><br><br>[2] <a href=\"collection.html#44\" onclick=\"location.hash = 44; StartingPost();\">show</a>"}, 
{"title": "molecular_computer_new.gif",
  "description": "This is how a molecular computer would look like, if seen with a magically powerful microscope. It is a single molecule which interacts randomly with other molecules, called \"enzymes\", invisible in this animation.<br><br>There is no control over the order of the chemical reactions. This is the idea, to compute without control.<br><br>The way it works is like this: whenever a reaction happens, this creates the conditions for the next reaction to happen.<br><br>There is no need to use a supercomputer to model such a molecule, nor is it reasonable to try, because of big number of the atoms.<br><br>It is enough instead to find real molecular assemblies for nodes, ports and bonds, figured here by colored circles and lines.<br><br>The only computations needed are those for simulating the family of rewrites - chemical reactions. Every such rewrite involves up to 4 nodes, therefore the computational task is handy.<br><br>Verify once that the rewrites are well done, independently of the situation where you want to apply them, that is all.<br><br>Once such molecular compounds are found, the next task is to figure out how to build (by chemical reactions) such molecules.<br><br>But once one succeeds to build one molecule, the rest is left to Nature way of computing: random, local, asynchronous.<br><br>From this stage there is no need to simulate huge molecules in order to know they work. That is something given by the chemlambda formalism.<br><br>It is so simple: translate the rewrites into real chemistry, they are easy, then let go the unneeded control from that point on.<br><br>This animation is a screencast of a part of the article Molecular computers<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/molecular.html\">link</a>, <a href=\"https://arxiv.org/abs/1811.04960\">arXiv:1811.04960</a><br>and everything can be validated (i.e. verified by your own) by using the chemlambda repository<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>Now I\u0027ll pass to a list of critics which, faced with the evidence, they look uninformed:<br>1. Chemlambda is one of those rewriting systems everybody knows. Ignorant claim, while it is true that some rewrites appear all over the place, from string theory to knot theory to category theory to geometry of interaction, the family of graphs considered is not the same, because those graphs are purely combinatorial object and they don\u0027t need a global embedding, like all other formalism do, in a schematic space-time. Moreover, the choice of the rewrites is such that the system works only by local rewriting and no global control on the cascade of rewrites. No other formalism from the family does that.<br><br>2. Is well known that all this is already done in the category theory treatment of lambda calculus.<br><br>False, if one really reads what they do in category theory with lambda calculus, then one figures quick that they can\u0027t do much for untyped lambda beta calculus, that is without eta reduction. This is mentioned explicitly in Barendregt, for example, but the hype around categories and lambda calculus is so pervasive that people believe more than what actually is.<br><br>3. Chemical computing is old stuff: DNA computing, membrane computing, the chemical abstract machine, algorithmic chemistry.<br><br>Just because it is chemical computing, it does not mean that it is in the family mentioned.<br><br>The first name of chemlambda was \"chemical concrete machine\" and there there are comparison with the chemical abstract machine<br><a href=\"https://arxiv.org/abs/1309.6914\">arXiv:1309.6914</a><br>(btw I see that some people discover now \"catalysts\" without credits in the written papers)<br>The cham is a formalism working with multisets of molecules, not with individual ones, and the computation is done by what corresponds to lab operation (splitting a solution in two, heating, cooling, etc)<br>The membrane computing work is done around membranes which enclose containers of multisets of molecules, the membrane themselves being some abstract concepts, of a global nature, whil ein reality, as well as in chemlambda, everything is a molecule. Membranes exist in reality but they are made of many molecular compounds.<br>DNA computing is an amazing research subject, which may be related to chemlambda if there is a realization of chemlambda nodes, ports and bonds, but not otherwise, because there is not, up to my knowledge, any model in DNA computing with the properties: individual molecules, random reactions, not lab operations.<br>Algorithmic chemistry is indeed very much related to chemlambda, by the fact that it proposes a chemical view on lambda calculus. But from this great insight, the paths are very different. In algorithmic chemistry the application operation from lambda calculus represents a chemical reaction and the lambda abstraction signals a reactive site. In chemlambda the application and lambda abstraction corresponds to atoms of molecules. Besides, chemlambda is not restricted to lambda calculus, only some of the chemlambda molecules can be put in relation with lambda terms, but even for those, the reactions they enter don\u0027t guarantee that the result is a molecule for a lambda term.<br><br>Conclusion: if you are a chemist, consider chemlambda, there is nothing like it already proposed. The new idea is to let control go and instead chain the randomly appearing reactions by their spatial patterns, not by lab operations, nor by impossibly sophisticated simulations.<br>Even if in reality there would be more constraints (coming from the real spatial shapes of the molecules constructed from these fundamental bricks) this would only influence the weights of the random encounters with the enzymes, thus not modifying the basic formalism.<br>And if it work in reality, even for only situations where there are cascades of tens of reactions, not hundreds or thousands, even that would be a tremendous advance in chemical computing, when compared with the old idea of copying boolean gates and silicon computers circuits."}, 
{"title": "monus_wo_T_short.gif",
  "description": "Lambda terms are molecular factories. Look here, I took the lambda term for the computation 3-20\u003d0, it\u0027s the mol file [1], and I erased the T (termination) nodes (lines 12 and 109). Then I used quiner_shuffle to run the computation.<br><br>With the T nodes there is a lot of trash which is produced, see the video [2].<br><br>Without them there is this funny looking \"bridge\" which builds double copies. Interesting, what can be good for, from a chemical point of view?<br><br>[1] monus.mol<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/monus.mol\">monus.mol</a><br><br>[2] Another lambda calculus reduction which works but gives lots of trash<br><a href=\"https://youtu.be/jrFtHVdO9GM\">youtube</a>"}, 
{"title": "monus_wo_T_spiral.gif",
  "description": "Birth of a machine."}, 
{"title": "multinum.gif",
  "description": "Baby octopus. A modification of the quadpod [1]. This grows from a mol file of a molecule which may give abnormal growth in some random runs, resulting in less than 8 arms.<br>The same happens for the pentapod [2], resulting in some variant of the unipod [3].<br><br>Done with multinum.mol from the chemlambda repository.<br>If you want to modify the number of arms then add or remove a pair of FOE-A nodes (but respect the wiring). This gives creatures with 2X the number of A nodes in the initial molecule (if there is no abnormal growth.<br><br>[1] Quadpod<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/quadpod.html\">quadpod.html</a><br><br>[2] Pentapod<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/pentapod.html\">pentapod.html</a><br><br>[3] Unipod (obtained from abnormal growth of a tripod)<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/unipod.html\">unipod.html</a><br><br>Instructions for making your animations<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>I used cycounter\u003d40, then in the multinum.html file which results from quiner.sh I modified the window to       var w \u003d 1000, h \u003d 1000; (to get a bigger window) and I relaxed gravity to    .gravity(.08)."}, 
{"title": "multiplex.gif",
  "description": "Difficult observation of spreading cloud of molecules. Done by using a previous chemlambda simulation (with actors). Which one?"}, 
{"title": "neuron_10X10_2_mod_deterministic_short.gif",
  "description": "Two neurons interacting, deterministic version. Compare with [1], which is the random version. This animation is done with moving_random_metabo.sh and with the molecule neuron_10X10_2_mod.mol from the library of chemlambda molecules [2].<br><br>By looking in the stats file (that\u0027s sta.txt) you can see that there is less parallelism compared with the a^a examples. The same happens with the ackermann molecules, or with any other example where there is used a function which is repeatedly applied to itself.<br><br>Also from the sta.txt file you can see series of bursts of activity. Such a burst is visible in the animation, where you may notice (in the left part) that it is related to a transfer from the neuron which is up to the neuron which is down. (Compared to [1], the neurons here appear upside down, and you may discern a piece of the same transfer at the right of the picture.)<br><br>Finally, what can be visually recognized as a thing, a \"neuron\" in this case, is a clump of molecules which changes slower than average. Indeed, most of the activity, during this burst, involves transfers between these two clumps, these two neurons. That means that what we notice as a structure is that place which does not compute, the less interesting part.<br><br>Is this a general phenomenon? I guess so. For example, when studying a dynamical system we are preoccupied by the invariants of the process, or the invariants are exactly those quantities which are constant during the computation (assuming that evolution\u003dcomputation). The invariants do not compute! Likewise, in classical models of computation where we think in terms of some flow of signals through gates, the graphical rewrites do not compute, they are means for defining equivalences between two computations.<br><br>Or, in reality, exactly the rewrites (aka chemical reactions) are those which compute, those which are interesting.<br><br><br>[1] Two neurons interacting<br><a href=\"collection.html#161\" onclick=\"location.hash = 161; StartingPost();\">show</a><br><br>[2] The library of chemlambda molecules<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "neuron_10X10_2_mod_short.gif",
  "description": "Two neurons forming and making connections"}, 
{"title": "neuron_10X10_2_short.gif",
  "description": "Two neurons interacting."}, 
{"title": "neuron_10X10_2_space.gif",
  "description": "Ghosts means recurrence. This post belongs to two threads:<br>- neural networks, continuing from [1]<br>- space constrains, continuing from [2]<br><br>The molecule represents a 2 layer recurrent network. Each layer is 10X10 linear. Each layer is called here a \"neuron\". See the post [4] with more explanations.<br><br>You have seen a simulation using this molecule here [3].<br><br>This time you see it (actually the first half of the simulation) with space constraints.<br><br>You see that initially the two \"neurons\" interact and they start to make something like ghosts of themselves, which further evolve into some baggy molecules (sign that they\u0027re maybe lambda terms). These bags will later interact and produce effects like in [1].<br><br>But the ghosts are clearly a sign of recurrence happening.<br><br><br><br>[1] Mini Boltzmann brain<br><a href=\"collection.html#79\" onclick=\"location.hash = 79; StartingPost();\">show</a><br><br>[2] Ackermann(4,4) goo with space constraints<br><a href=\"collection.html#60\" onclick=\"location.hash = 60; StartingPost();\">show</a><br><br>[3] Two neurons interacting<br><a href=\"collection.html#161\" onclick=\"location.hash = 161; StartingPost();\">show</a><br><br>[4] RNN again<br><a href=\"collection.html#165\" onclick=\"location.hash = 165; StartingPost();\">show</a>"}, 
{"title": "neuron_10X10_2_S_short.gif",
  "description": "Neurons improved. Along the idea that the network is the computation. I used the mol file neuron_10X10_2_S.mol which will be available after updates of the library of chemlambda molecules [1].<br><br>[1] Library of chemlambda molecules<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "neuron_10X10_2_ver_2.gif",
  "description": "Rosenkrantz and Guilderstern. Only two mutations transform the two neurons interacting [1] into computing dust [2].<br><br>[1] Two neurons interacting<br><a href=\"collection.html#161\" onclick=\"location.hash = 161; StartingPost();\">show</a><br><br>[2] What a piece of work is a man<br><a href=\"https://en.wikipedia.org/wiki/What_a_piece_of_work_is_a_man#The_speech\">wikipedia</a>"}, 
{"title": "neuron_10X10_2_ver_short.gif",
  "description": "RNN again. This is a more complete animation than the previous one. I call them \"neurons\" but really this is a simulation of a two layers, recurrent linear network. Each layer (or \"neuron\") has 10 inputs and 10 outputs. The first layer has 5 of the inputs fed with data, and the remaining 5 inputs connected to 5 outputs of layer 2 (or \"neuron* 2). The neuron 2 has all the inputs coming from the outputs of neuron 1, 5 outputs connected back to the neuron 1\u0027s inputs (as explained) and the remaining 5 outputs are the output of the network. But, the difference is that we don\u0027t see these neurons, we see instead what is happening, what the network \"thinks\" during the computation. That is because the layers (and the internal computations) are not done by signals transmitted through bonds, but they are done by cascades of reactions, thus by \"signal transduction\".<br>Also, there is no separation into training and running, nor there are weights on bonds which change during the evolution of the network. Something different happens here.<br>The \"neurons\" and their exchanges are programs themselves. Without any external direction, the evolution of the system passes roughly by 3 phases. I need to make you aware of some details in the images in order to make easier the visualization of the phases.<br>So, you notice at the beginning, and for some time into the simulation, the presence of three stick-like subgraphs: two are long and one is short. The two long ones, the mostly green one belongs to the first \"neuron\" and the red and green one to the second \"neuron\". The short, bluish stick is the output of the graph.<br>The 3 phases are:<br>1. at the beginning the neurons (I\u0027ll renounce at \"\") behave differently. At the left is the second neuron, which interacts with the first and adapts, waiting for the data output of the first neuron. Likewise, the first neuron, at the right, adapts to the second one and also starts to process the external input data. At this phase we can still see the neurons as related to the layers which support them, in a sense (although in chemlambda these layers are not present, they are a matter of interpretation only).<br>2. The mostly green long stick of the first neuron is consumed after the first neuron learns and processes the data. You see just before the consumption of the green long stick, something like a branch of a tree which is then processed itself in the same time as the stick is consumed. That\u0027s what the first neuron transmit to the second, besides the interactions which have taken place before at the phase 1.<br>3. From this point is no longer clear where the computation happens, probably in both layers, but they are now highly and dynamically related. At some point the remaining long stick, the one of the second neuron is consumed, meaning that the second neuron will output soon. We see then the final disappearance of the short bluish stick and the splitting of the graph into 5 pieces (and two yellow dots which are garbage). This is the output, there are two outputs of data (the small baggy graphs which can be seen between the two yellow garbage dots) and 3 active graphs. The activity is disconnected, the outputs reflect that the network did a sort of projection of the input onto a smaller dimensional space.<br>Where is the activity happening? I don\u0027t know, probably both neurons are involved.<br>What is this good for?<br>For the moment these are experiments with the architecture."}, 
{"title": "neuron_10X10_6_ver.gif",
  "description": "6 neurons with more visible bonds. Same initial molecule as in the Gulumbu Yunupingu inspired post [not available]"}, 
{"title": "neuron_10X10_in_10X10_edit1.gif",
  "description": "4 levels deep RNN. Have to change to movie format. And to go back to basics of space with all the fun experience acquired with this chemlambda project.<br><br>It is time to pass to a new, more complex level. Is clear that this format is not enough, cannot do justice to the background research. On the other side, it is, hopefully, visually striking enough to make us think more about some pretty difficult subjects.<br><br>You can help this project by sharing this collection, by talking about it or by going to the metal level of the programs. This gives me leverage in the real effort to move things a bit, in this extreme way."}, 
{"title": "neurons_composite_lossy.gif",
  "description": "Neurons composite image. Look at it at full size!"}, 
{"title": "newfact_zero_1.gif",
  "description": "The madness 81 group of experiments. (part I)<br>There are molecules in chemlambda which may exhibit very different evolutions, caused by the randomness of the rewrites. For applications we wish to design the molecules such that the outcome is the same all the time, or such that the molecule evolves in a way which we can describe. As examples of the first situation are the molecules used for classical examples like the Ackermann function [1] and the factorial [2]. Chemlambda quines are examples of the second situation.<br><br>Sometimes we wish for variety and unexpected.<br><br>There are molecules like this. Some time ago I made a video called The answer to the madness is 81 [3], followed by another one [4].<br><br>The name comes from the fact that the molecule used ended up by being the one for the (Church encoding for) 81, but otherwise there was an apparent madness of cascades of rewrites, almost all the video.<br><br>I changed the molecule, now I use newfact_zero.mol from the chemlambda repository.<br><br>I want to show you several ways it can evolve.<br><br>The animation is a 64X sped screencast. After some things which are too fast to understand, the molecule seems locked into a repeating pattern of rewrites which makes it grow into an endless spiral.<br><br>You can see a different result in the demo [5].<br><br><br>[1] Ackermann(2,2) demo<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/random_ackermann_2_2.html\">ackermann_2_2.html</a><br><br>[2] The working factorial demo<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/lisfact_2_mod.html\">lisfact_2_mod.html</a><br><br><br>[3] The answer to the madness is 81<br><a href=\"https://youtu.be/8x31p-xYJSg\">youtube</a><br><br>[4] Topological morphing in the \"Answer to the madness is 81\"<br><a href=\"https://youtu.be/rAJ2ADLaVmc\">youtube</a><br><br>[5] Topological complexity<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/newfact_zero.html\">newfact_zero.html</a>"}, 
{"title": "newfact_zero_5.gif",
  "description": "The madness 81 group of experiments. (part II)<br>This is another possible outcome of the random evolution of the molecule newfact_zero.mol. Continues the thread from [1].<br><br>A 16X sped screencast of an animation obtained with quiner.sh and newfact_zero.mol from the chemlambda repository [2].<br><br><br>[1] The madness 81 group of experiments (part I)<br><a href=\"collection.html#169\" onclick=\"location.hash = 169; StartingPost();\">show</a><br><br>[2] chemlambda repository instructions<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "newfact_zero_6.gif",
  "description": "The madness 81 group of experiments (part III)<br>As you have seen in (part I) and (part II), the \"badly\" designed molecule newfact_zero.mol<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/newfact_zero.mol\">newfact_zero.mol</a><br>may evolve in various way under the random reduction algorithm.<br><br>This is yet another one.<br><br>This is a 128X sped screencast of the animation obtained with quiner.sh<br>and newfact_zero.mol<br><br>Make yourself one, which is the result? A digital art form?<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[1] The madness 81 group of experiments (part I)<br><a href=\"collection.html#169\" onclick=\"location.hash = 169; StartingPost();\">show</a><br><br>[2] The madness 81 group of experiments (part II)<br><a href=\"collection.html#170\" onclick=\"location.hash = 170; StartingPost();\">show</a>"}, 
{"title": "omegafo_mod.gif",
  "description": "Omega duplication. it became easy to make quines (artificial organisms in chemlambda) which duplicate, based on combinators without normal form and hybridisations. Here is a short avi movie about one which is obtained from the only quine in lambda calculus, the omega combinator, turned into chemlambda and modified into a chemlambda quine which also duplicates."}, 
{"title": "out.gif",
  "description": "+sreejith s : \"The above screencast shows under-the-hood working of chemlambda-py. It\u0027s still under development. Core features are already implemented. Chemlambda-py is intended to be used as a python package around which various flavours of chemlambda can be build.\"<br><br>Work in progress on the chemlambda-py:<br><a href=\"https://github.com/4lhc/chemlambda-py/blob/master/README.md\">link</a><br>Thank you +sreejith s !<br>Let\u0027s do more stuff."}, 
//{"title": "pants_twisted_L.gif",
//  "description": "Third fractal in the series, after [1] and [2].<br><br>[1] Fractal 256<br>[not available]<br><br>[2] Fractal pants<br><a href=\"collection.html#174\" onclick=\"location.hash = 174; StartingPost();\">show</a>"}, 
{"title": "pants.gif",
  "description": "Fractal pants. I made a molecule which is like what the geometers call a \"pair of pants\", then I connected the loose ends and I got a fractal in the making. If you want to see another fractal looking molecule (but from a different reason) then see the previous post [1].<br><br>[1] Fractal 256<br>[not available]"}, 
{"title": "pattern_1_rand.gif",
  "description": "Random healing grid made by random pairs of nodes A-L (the beta move pattern) and FI-FOE (the complementary move), preserves the connectivity of the nodes from the sides under random reductions, while gradually becoming, very slowly, more randomly connected inside."}, 
{"title": "pattern_3_rand.gif",
  "description": "Bigger healing grid than [1].<br><br>[1] Random healing grid<br><a href=\"collection.html#175\" onclick=\"location.hash = 175; StartingPost();\">show</a>"}, 
{"title": "pattern_4_FO_A.gif",
  "description": "Disorder from a very regular state. Like the last two animations of random healing grids [1] [2] this is initially a regular web made of pairs of nodes. This time the randomness of reductions explodes the regular grid.<br><br>It happens gradually though, because the pair of nodes are FO and A. The application node A is duplicated by FO (of another pair) and it produces FOE nodes too. These fresh FOE nodes in turn duplicate the FO nodes as well.<br><br>You can see in the animation that I \"nailed\" four nodes from the corners of the initial grid. This is possible because the animation is done from the result of the simulation, which is a javascript file, which we can play with, as explained in [3].<br><br>[1] Bigger healing grid<br><a href=\"collection.html#176\" onclick=\"location.hash = 176; StartingPost();\">show</a><br><br>[2] Random healing grid<br><a href=\"collection.html#175\" onclick=\"location.hash = 175; StartingPost();\">show</a><br><br>[3] Playing with a quine while it reduces<br>[not available]"}, 
{"title": "pauvres.gif",
  "description": "Recently appeared in discussions and documents, this unfortunate \"scholarly poor\" tag. I used Google translate to French and ... truth has a way to emerge :) #OA2020 #openaccess"}, 
{"title": "pcompo.gif",
  "description": "Permutations composition. Two permutations of 8 elements are composed. One permutation is the cycle 1 - \u003e 2 - \u003e 3 - \u003e 4 - \u003e 5 - \u003e 6 - \u003e 7 - \u003e 8 - \u003e 1 and the other is made of two cycles 1 - \u003e 2 - \u003e 3 - \u003e 4 - \u003e 1 and 5 - \u003e 6 - \u003e 7 - \u003e 8 - \u003e 5.<br>They are composed as lambda terms are composed (i.e. via Lxyx.x(yz) ) but used 8 times, one for each output of the permutation molecule.<br><br>Want to see clearly what am talking about? Look at the mol file I used:<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/pcompo.mol\">pcompo.mol</a><br><br>For visualization I used quiner.sh and the deterministic reduction algorithm (i.e. set all wei_... \u003d 0 in quiner.awk).<br><br>All in the repository <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "periodic_8.gif",
  "description": "The path shortening phenomenon. I\u0027ll put the metric geometer\u0027s hat for this post. Here is a curious fact about chemlambda quines.<br>Recall that such a quine is a molecule, a graph in chemlambda, with the property that under deterministic reduction, such that the DIST moves have precedence over the others in case of conflict, it has a periodic evolution. That means that there is a number N such that after N steps of the deterministic algorithm (with the priority of DIST over BETA and FAN-IN) we obtain a graph isomorphic with the initial graph.<br><br>OK, so what?<br><br>In the image you see such a quine, which is made of 36 smaller quines, entangled (i.e. hybridised in the chemlambda parlance) into 4 rings of 9 pieces each, and then hybridised a little bit more, in order to connect the 4 rings. The molecule is periodic_8.mol from the chemlambda repo.<br><br>You see the result of a cascade of random rewrites, and you can observe that the graph becomes more and more compact.<br><br>Why?<br><br>Well, the curious phenomenon is the following. Consider a graph made only of the trivalent nodes, so that only DIST, BETA and FAN-IN rewrites can be applied. The COMB rewrites are of course present and they are applied all the time, so I\u0027ll suppose that they come and do what they do after every other rewrite. Further I\u0027ll mention them only once.<br><br>Refresh your memory with the rewrites list [1].<br><br>Remark that when a rewrite from the list DIST, FAN-IN, BETA is applied, any path in the graph either preserves it\u0027s length or it gets shorter. Indeed, this follows from looking at the rewrites (continued by the elimination of Arrow elements by the COMB). A path in the graph either passes through a left pattern for a rewrite or it doesn\u0027t. If it doesn\u0027t then the rewrite does not affect it. If it does pass through a pattern for FAN-IN or BETA, then it gets shortened. If it passes by one of the DIST rewrites then it changes (because of the addition of new nodes) but any of the daughter paths have the same length as the one before the rewrite.<br><br>In the case you are looking at, this is visible because of the hybridisations. You see that the graph becomes more compact because the length of the paths decrease during this movie, and because the effect of the hybridisations spread along the graph.<br><br>But this is also contrary to intuition. Because the phenomenon should be present also in the deterministic reduction. How is then possible to have a sequence of graphs with the properties that all the paths get shorter or stay the same, that there are surely paths which get shorter (because there have to be DIST moves to compensate for the loss of nodes by BETA and FAN-IN), but still the evolution of the graph is periodic?<br><br>There is no contradiction.<br><br>What means that a path gets shorter? The space of paths changes during the evolution of the graph. There is an order relation which is generated by the mother-daughter paths relation (i.e. a daughter path is any one which is obtain from the mother path by replacing the part of the path in a rewrite pattern by any path which connects the same external ports, belonging to the pattern after the rewrite; mind that the edges of chemlambda graphs are oriented, and so are the paths I consider).<br><br>So there is no path which gets shorter, actually, but instead there is a property of the path length functional which says that it is non-increasing along any ordered chain of paths.<br><br>[1] The moves page<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/moves.html\">link</a>"}, 
{"title": "permutation.gif",
  "description": "Permutations. Consider the permutation p\u003d1-\u003e2-\u003e3-\u003e4-\u003e1, it has the property that p^4 \u003d identity, i.e. 1-\u003e1, 2-\u003e2, 3-\u003e3, 4-\u003e4.<br>The animation shows this in chemlambda.<br>What you see.<br>- at the beginning there are 4 magenta free out nodes, connected to a tree of yellow fanout nodes (FOE), then there are two bags<br>- the bag from the left, mostly green, is the number 4 in Church notation<br>- the bag from the right, made of red nodes, contains the permutation<br><br>-at the end you see the identity permutation, made of 4 identity combinators (the identity combinator is Lx.x)<br><br>Details.<br>Let\u0027s start from the mol file permutation.mol,<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/permutation.mol\">permutation.mol</a><br>which contains the initial molecule.<br><br>It has the following structure:<br><br>FOE 1out 11out 12out<br>FOE 2out 21out 22out<br>FOE 1 1out 2out<br><br>\\\\ which is the tree of yellow fanout nodes, with free ports 11out 12out 21out and 22out and root 1<br><br>A num 2 1<br><br>\\\\ i.e. apply num(ber) to the port 2 and connect to the root 1 of the fanout tree<br><br>FI p12 p34 2<br>FI p1 p2 p12<br>FI p3 p4 p34<br><br>\\\\ the mirror tree made of fanins (red nodes, seen as part of the bag which represent the permutation). this tree has 2 as root and input ports p1, p2, p3, p4<br><br>L 1num fnum num<br>L 2num xnum 1num<br><br>FO fnum m1num l1num<br>A m1num r1num 2num<br><br>FO l1num m2num l2num<br>A m2num r2num r1num<br><br>FO l2num m3num l3num<br>A m3num r3num r2num<br><br>A l3num xnum r3num<br><br>\\\\ this was the number 4 in Church notation, transformed into a chemlambda molecule<br><br>\\\\ and here is the permutation:<br><br>L a4 a1 p1<br>L a1 a2 p2<br>L a2 a3 p3<br>L a3 a4 p4<br><br>What happens. The number 4 is sucked by the tree of FOE nodes and starts to replicate, but in the same time, as soon as there is a possibility, it starts to replicate the permutation itself and apply it to itself.<br><br>Recall that if you have a number N expressed as a lambda term, and another term B, then NB means \"apply B N times to...\".<br><br>So that\u0027s it, only that its asynchronous, there is no clear separation between replications and applications, the permutation is not applied as a function (parts of it are replicating, other parts are applied)... funny right?<br><br>Validation Use the permutation.mol with the script quiner.sh, as explained at<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "per_succ_nswe.gif",
  "description": "Build with permutations. There are several simulations with my mock ebola matrix constructor, like [1] where Turing machines are mixed with the tube constructor. This time I replaced the very low activity tube constructor with a permutation. It means that from the moment it\u0027s created, there are cascades of compositions of permutations which consume the creation. There is no matrix to be seen, except maybe in time.<br><br><br>[1] Turing machines grafted on the mock ebola matrix constructor<br><a href=\"collection.html#204\" onclick=\"location.hash = 204; StartingPost();\">show</a>"}, 
{"title": "piece_of_firstcell_proto_5_23steps.gif",
  "description": "In vitro \"studies are performed with microorganisms, cells, or biological molecules outside their normal biological context. [...] Studies conducted using components of an organism that have been isolated from their usual biological surroundings permit a more detailed or more convenient analysis than can be done with whole organisms. In contrast, in vivo studies are those conducted in animals, including humans, and whole plants.\" [1]<br><br>I took one of the artificial cell prototypes and \"grown\" it until it reached about 50000 nodes. Because I can simulate it fast on my computer, but I can\u0027t visualize the result at this scale, I applied the \"in vitro\" and I extracted contiguous (in the resulting mol file) pieces of about 1/100 size of the whole cell. Then I evolved the pieces in isolation and visualized them.<br><br>What you see is a typical piece and it\u0027s evolution.<br><br>It is interesting because it has been speculated that for big mol files, small parts of them would be meaningless. This is not because of some obfuscation technique, but because of the same phenomenon which is encountered in biology, where in vitro observations are far less meaningful than in vivo ones. (In the same time, the complexity of in vivo is most of the time beyond the reach of the human observers and their labs).<br><br>We see lots of small pieces, only some of them reducing further, not for a long time.<br><br>Likewise, in a hypothetical decentralized chemlambda computation, the access to a small (but not very small, here 1/100 or even 1/50 looks the same, I tried) part of the graph (for example the states of a part of the actors involved in computation) does not tell much about what\u0027s happening.<br><br><br><br>[1] In vitro, wikipedia<br><a href=\"https://en.wikipedia.org/wiki/In_vitro\">link</a>"}, 
{"title": "pred_3_exp_4.gif",
  "description": "Predecessor of a fractal (2). This the predecessor of the fractal molecule 3^4. I used quiner_shuffle.sh after inhibiting a bit the A-FOE move (wei\u003d50 in the quiner_shuffle.awk for that move) and the mol file file.mol which corresponds to the file.gif you see, from the chemambda collection of molecules [1]. Instructions of use the chemlambda active branch at [2].<br>Why is that interesting: for building molecular computers, which may be many orders of magnitude superior to silicon computers, see [3] and THINK HARD if you are a chemist.<br><br>The first predecessor of a fractal post is [3].<br><br>[1] Chemlambda molecules collection<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[2] Chemlambda active branch, use instructions<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[3] Predecessor of a fractal<br>[not available]"}, 
{"title": "pred_4_exp_4_fin.gif",
  "description": "Predecessor of a fractal. Recall from [1] that 4^4 computed with chemlambda from the molecule of the corresponding lambda term is not what one expects, but looks more like a fractal. So, let\u0027s apply the predecessor (molecule) to it. Result? Diffusion again, resembling with [2].<br>Explanation. The predecessor term applied to a Church number is a simple but interesting thing in chemlambda. The Church number is basically a circular train track and the predecessor generates a walker (sometimes the whole thing is called an ouroboros) which just walks around the track until it comes back to the beginning. There, there is a little surprise left by the predecessor, which kills both one application node and the walker.<br>Here the predecessor generates 16 walkers, progressively, diffusing to the \"fractal like boundary\" of the 4^4 molecule.<br>Not figured in the animation, because of gif length constraints, but what happens next is that each of these 16 walkers travel along 1/16 of the \"boundary\", in an asynchronous way, then one of them arrives to the \"surprise\" and it dissapears, sending signals to the others to come back to the center of the image and die.<br><br>There\u0027s no director of this play. There\u0027s no plan dictated in advance.<br><br>[1] Fractal 256<br>[not available]<br><br>[2] Containment and diffusion<br><a href=\"collection.html#246\" onclick=\"location.hash = 246; StartingPost();\">show</a>"}, 
{"title": "pred_5_exp_4_fin.gif",
  "description": "Bigger fractal than [1]<br><br>[1] Predecessor on a fractal<br><a href=\"collection.html#185\" onclick=\"location.hash = 185; StartingPost();\">show</a>"}, 
{"title": "protein_packing.gif",
  "description": "Protein. The molecule from the start of the animation satisfies the definition of a protein in the sense that it is made by a packing of several 1-dimensional strings:<br>- a permutation [1], in this case one of 30 elements; or in chemlambda permutations appear as cycles (1-dim graphs), like in the graphical representation of a permutation as a collection of cycles (4 of them for this particular permutation)<br>- a zipper [2], which is a one dimensional string of A atoms, followed by another 1-dim string of L atoms<br><br>When the invisible graph-rewriting enzymes start to work (deterministic evolution in this case [3]), the permutation becomes active first, then the zipper.<br><br>The invisible enzymes complex which are active here could be called a ribosome [4].<br><br>At the beginning of the animation you see the zipper pair of strings, because the permutation part of the \"protein\" is already converting into a permutation of some of the atoms!<br><br>Then the zipper becomes active and at the end you see a lot (30) of pairs of FRIN-FROUT nodes.<br><br>These pairs represent the edges of a graph. For convenience I erased the nodes of that graph.<br><br>Here is the explanation.<br><br>A chemlambda molecule is a graph made of nodes (A, L, FI, FO, FOE, ...) and bonds. The hypothesis is that one can synthetize a chemlambda molecule starting from a list of generic A, L, FI, ... nodes, with ports enumerated in a given order, and a list of edges which define the bonds between these ports.<br><br>Everything should be another chemlambda molecule, which rewrites itself into the final (synthetized) molecule, with the help of the rewriting (invisible) enzymes.<br><br>The permutation part is the one which represent the bonds.<br><br>Indeed, the atoms have a list of ports (which can be in or out ports) and the bonds appear as a permutation from the in ports to the out ports.<br><br>[1] the last post on permutations in chemlambda is <a href=\"collection.html#189\" onclick=\"location.hash = 189; StartingPost();\">show</a><br><br>[2] Zipper logic<br><a href=\"collection.html#67\" onclick=\"location.hash = 67; StartingPost();\">show</a><br><br>[3] For visualization I used quiner.sh and the deterministic reduction algorithm (i.e. set all wei_... \u003d 0 in quiner.awk).<br><br>For the moment I don\u0027t give the mol file, because is work in progress.<br><br>But read for instructions <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>﻿<br><br>[4] Ribosome<br><a href=\"https://en.wikipedia.org/wiki/Ribosome\">wikipedia</a>"}, 
{"title": "pwheel_32_trans.gif",
  "description": "Taking shape. The transactions point of view [1] looks more like real chemistry. This is a transaction computed from the molecule pwheel_32.mol from the chemlambda library of molecules.<br><br>Transactions will probably make a separate subject with it\u0027s own repository. The actual one achieved the goal to soften the point of view of many people about this subject. It is time to go further, differently.<br><br>[1] Competing chemical transactions and emergence of chemlisps<br><a href=\"collection.html#209\" onclick=\"location.hash = 209; StartingPost();\">show</a>"}, 
{"title": "pwheel_8_compo.gif",
  "description": "Another fresh self-composition of a permutation, details in<br><a href=\"https://chorasimilarity.wordpress.com/2015/07/22/permutation-replication-composition-all-in-one/\">link</a>"}, 
{"title": "pwheel_8_deterministic.gif",
  "description": "Atomic heart quine. This shows that the permutation wheel quine is a chemlambda quine.<br>You see the reduction of pwheel_8.mol, with quiner.sh, with all weights set to 0 (in quiner.awk).<br>This means it is a deterministic reduction.<br><br>Done with the mentioned files from the chemlambda repository<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "pwheel_8_hyb_mono.gif",
  "description": "Transport line. This is a quiner experia run of the permutation wheel quine, at the stage where only one active site travels around the circular track.<br>See the older posts about the permutation wheel quine [1] and about road traffic [2].<br>I used pwheel_8_hyb.mol and quiner_experia.sh from the repo [3].<br><br>[1] Permutation wheel<br><a href=\"collection.html#192\" onclick=\"location.hash = 192; StartingPost();\">show</a><br><br>[2] Road traffic<br>[unavailable]<br><br>[3] README.md<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
//{"title": "pwheel_8_hyb.gif",
//  "description": "Road traffic. Do you recall those experiments with many cars running on a circular road? After some time where there is a chaotic behaviour, there appears a wave of ripples in the traffic, meaning that most of the cars lock into a smooth driving experience, excepting localized waves of brake or accelerate moves, which travel along the cars.<br>Same here in chemlambda, where I did a hybrid of two 8-cycle permutations and I obtained a 16-cycle permutation wheel. This is a new kind of quine, as explained in [1].<br><br>Now, imagine that each magenta dot represents a car. The cars are on a circular track.<br><br>After a complex behaviour, there are \"worms\" made of either green-yellow segments, or red-yellow segments.<br><br>Imagine that green-yellow means the intention to accelerate and yellow-red means the intention to brake.<br><br>You see in the first part of the animation that these worms make branched structures, with branches for accelerate and branches for braking.<br><br>The thing (collection of cars if you want) takes emergent decisions!<br><br>Finally there are two green-yellow worms, traveling like two accelerate waves along the cars cycle.<br><br>Done with quiner.sh and pwheel_8_hyb.mol from the chemlamdba repository, see [2] for instructions.<br><br>[1] Permutation wheel<br><a href=\"collection.html#192\" onclick=\"location.hash = 192; StartingPost();\">show</a><br><br>[2] readme<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "pwheel_8_long.gif",
  "description": "Permutation wheel As anticipated, we can use permutations in chemlambda to do funny stuff. Here: a permutation quine. It is short lived and manifests several regimes. Towards the end we see two, then one traveling Y combinator. Then it dies like in the neuron example.<br><br>Done with pwheel_8.mol and quiner.sh from the chemlambda repository."}, 
{"title": "qui1.gif",
  "description": "Play with artificial microbes.<br>How: <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br>Video: <a href=\"https://youtu.be/IYAOPsAYbAI\">youtube</a>"}, 
{"title": "quine_lock_double_synt_det.gif",
  "description": "Now you see it, now you don\u0027t, until the end when you see it again. I used the deterministic reduction for a \"bubble\" quine. After the first short part, when you see that the quine is synthetized, for the rest of the simulation the quine is not visible, only the product of the reaction is. This is interesting because of the following.<br><br>In [1] I introduced the idea that every graph rewrite is like a chemical interaction with an invisible enzyme. Imagine that before the graph rewrite we have the molecule A, which is going to pass by the rewrite R. After the rewrite it becomes the molecule B.<br><br>In graph-rewrite formulation this transformation looks like<br><br>A - - \u003e (R) - - \u003e B<br><br>In the chemical version formulation R is itself a molecule, an enzyme. The reaction is<br><br>A + R - - \u003e B + R + garbage<br><br>\"Garbage\" are the Arrow nodes, which are wiped out by the COMB cycle (see it towards the end of the rewrites description [2]).<br><br>The enzyme R is invisible, i.e. it does not appear as a graph in the chemlambda formalism. But can we make it visible?<br><br>Yes, for example take R to be (related) to a (well chosen) quine and interpret the chemical version of the reaction as if it is the graph rewrite version.<br><br>[1] Chemical concrete machine<br><a href=\"https://arxiv.org/abs/1309.6914\">arXiv:1309.6914</a><br><br>[2] Chemlambda moves<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/moves.html\">link</a>"}, 
{"title": "ringduplication.gif",
  "description": "The replication mechanism for circular bacterial chromosomes is known. <a href=\"https://en.wikipedia.org/wiki/Circular_bacterial_chromosome\">wikipedia</a><br>In the artificial chemistry chemlambda we can do something similar.<br><br>Explanations:<br><br>0. (few words about validation) If you have the alternative to validate what you read, then it is preferable to authority statements or hearsay from editors. Most often they use anonymous peer-reviews which are unavailable to the readers.<br><br>Validation means that the reader can make an opinion about a piece of research by using the means which the author provides. Of course that if the means are not enough for the reader, then it is the author who takes the blame.<br><br><br>This animation has been done by screen recording of the result of a computation. As the algorithm is random, you can produce another result by following the instructions from<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br>I used the mol file model1.mol and quiner.sh. The mol file contains the initial molecule, in the mol format. The script quiner.sh calls the program quiner.awk, which produces a html and javascript file (called model1.html), which you can see in a browser.<br>I added text to such a result and made a demo some time ago (when? look at the history in the github repo, for example: <a href=\"https://github.com/chorasimilarity/chemlambda-gui/commits/gh-pages/dynamic/model1.html\">link</a> )<br>Enough said!<br><br>1. Chemlambda is a model of computation based on artificial chemistry which is claimed to be very closed to the way Nature computes (chemically), especially when it comes to the chemical basis of computation in living organisms.<br>This is a claim which can be validated through examples. This is one of the examples. There are many other more; the chemlambda collection shows some of them in a way which is hopefully easy to read (and validate).<br>A stronger claim, made in the article Molecular computers, is that chemlambda is real chemistry in disguise, meaning that there exist real chemicals which react according to the chemlambda rewrites and also according to the reduction algorithm (which does random rewrites, as if produced by random encounters of the parts of the molecule with invisible enzymes, one enzyme type per rewrite type).<br>This claim can be validated by chemists.<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/molecular.html\">link</a>, <a href=\"https://arxiv.org/abs/1811.04960\">arXiv:1811.04960</a><br><br>2. To the matter, a circular DNA replicates, or duplicates, by the propagation of the replication forks.<br>More interesting for me is that there is a recent Nature Nanotechnology Letter \"Self-replication of DNA rings\" <a href=\"https://www.nature.com/nnano/journal/vaop/ncurrent/full/nnano.2015.87.html\">link</a> which looks (to my eyes) even closer to the animation I present here.<br>(Learned about it from a post [not available] by +Cellular Computing )<br><br>3. In the animation the duplication of the ring molecule is achieved, mostly, by the propagation of chemlambda DIST rewrites. A rewrite from the family DIST typically doubles the number of nodes involved (from 2 to 4 nodes), which vaguely suggest that DIST rewrites may be achieved by a DNA replication mechanism.<br>(List of rewrites here:<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/moves.html\">link</a> )<br><br>So, from my point of view, the question I have is: are there DNA assemblies for the nodes, ports and bonds of chemlambda molecules?<br><br>4. The animation has two parts. In the first part you see the ring molecule with some (free in FRIN and free out FROUT) nodes fixed. Actually you may attach more graphs at the free nodes (yellow and magenta 1-valent nodes in the animation).<br><br>You can clearly see the propagation of the DIST rewrites. In the process, if you look closer, there are two nodes which disappear. Indeed, the initial ring has 9 nodes, the two copies have 7 nodes each. That is because the site where the replication is initiated (made of two nodes) is not replicated itself. You can see the traces of it as a pair of two bonds which connect, each, a free in with a free out node.<br><br>In the first part of the animation is not clear that we get two disconnected rings out of one. That is why, in the second part of the animation, the same run is repeated, this time without fixing the FRIN and FROUT nodes before the animation starts.<br><br>Now you can see the two copies, each with 7 nodes, and the remnants of the initiation site, as a two pairs of FRIN-FROUT nodes."}, 
{"title": "ringo.gif",
  "description": "The story of the first artificial life organism in chemlambda.<br><br>Before having means to look at animations, I was trying various lambda terms in the artificial chemistry chemlambda. (It was the chemlambda v1, with only one type of fanout node, but that\u0027s not important).<br><br>One of the examples was a lambda term which corresponds to the predecessor (i.e. the term which behaves like this: when applied to a natural number (aka Church number) it reduces to the predecessor of that number, excepting the case when the number is 0, when it reduces to 0).<br><br>I had a way to transform lambda terms into chemlambda molecules and I was curious how the (chemlambda) reductions work. Better: what they look like.<br><br>These were hand calculations, like those explained in several posts at my open notebook (curious? type \"ouroboros\" in the search box at chorasimilarity.wordpress.com).<br><br>I noticed that after some first reductions, there is a repeating pattern of rewrites which continue for a while.<br><br>This leads to chemlambda quines. Now fast forward to the present.<br><br>Look at the animation.<br><br>You can see a \"walker\" propagating along the circular shape made of FOE (yellow) and A (green) nodes. If you mentally delete the nodes from the top of the image and you replace them by pairs FOE-A then you get something like a circular train-track where the \"walker\" can propagate indefinitely!<br><br>This circular molecule (which has a part which is the \"walker\" and another part which is the \"train-track\") does remains the same during the computation, because the behaviour of the \"walker\" is that it eats the train-track at one end and it re-builds it at the other end.<br><br>So, globally, is like the same image, only rotated a bit.<br><br>This led to the (obvious now) idea of a chemlambda quine: a graph which (if reduced deterministically) is isomorphic, after a reduction step, with the graph before the reduction.<br><br>In the random reduction version, chemlambda quines are like living microbes which have a life of their own.<br>(More about this, for example, in the post<br><a href=\"collection.html#4\" onclick=\"location.hash = 4; StartingPost();\">show</a> )<br><br>Validation: done with quiner.sh , exacly like in the demo <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/bigpred.html\">bigpred.html</a> but for a mol file obtained by replacing FO by FOE in the mol file bigpred.mol (available from the repository).<br><br>See the readme file<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br>for instructions of use of the repo."}, 
{"title": "ring_play.gif",
  "description": "A census of small molecules is needed. Before these animations I started an exploration of small molecules in chemlambda and learned that there is great diversity of behaviours even for very small ones, with 2, 3 or 4 nodes. Don\u0027t be fooled, how many different such molecules with at most 4 nodes are there? Hundreds? Thousands? More?<br>I explored the 2 nodes molecules and a part of the space of 3 nodes or pairs of 2 nodes ones. About a third of them are very active (which reminds me that about a third of rules of small cellular automata are universal).<br>What about putting several of them together and let them interact over a neutral background? Here, in this animation I made first a ring of FOE-A pairs, the usual train tracks, then I modified its topology by introducing some loops and some junctions. Then I added two walkers-generating and another small molecule and looked what happens.<br>A lot, actually, but not beyond geometrical understanding. Can you track their interactions?"}, 
{"title": "rug_fofo.gif",
  "description": "Green leaves are created by a small modification of the previous [1] simulation. The initial double tree has now 3 kinds of nodes, FI and FOE, as previously (grey) and FO (green). There is a race between FI-FO interactions (which are multiplications) and FI-FOE (which decrease the number of nodes). The green FO nodes also multiply by FO-FOE interactions, which are visible as a proliferation of green leaves in half of the double tree.<br>For programmers: all these 3 nodes, FI, FO, FOE, make the backbone of chemlambda, they don\u0027t have much to do with lambda calculus especially, they can be used with any programming language, expressed as AST.<br>For chemists: all these 3 nodes (and the invisible \"enzymes\") make the backbone of building structure from structure, without any computation overload, once the basic (here FI-FO, FI-FOE, FO-FOE) reactions are possible. They might be used with many other ingredients external to the formalism. Lambda calculus is only an inspiration for design, much more powerful than the usual preferred boolean calculus (and processing calculi are a form of vitalism, forget it and grow up).<br><br>[1] Half-life of double-trees<br><a href=\"collection.html#200\" onclick=\"location.hash = 200; StartingPost();\">show</a>"}, 
{"title": "rug_fo.gif",
  "description": "The missing link between the half-life of double trees animation [1] and green leaves [2]. Only one node difference between this and [1], namely a single FO (green) node. In [2], there is a whole tree of FO nodes, instead.<br><br>[1] Half-life of double-trees<br><a href=\"collection.html#200\" onclick=\"location.hash = 200; StartingPost();\">show</a><br><br>[2] Green leaves<br><a href=\"collection.html#198\" onclick=\"location.hash = 198; StartingPost();\">show</a>"}, 
{"title": "rug.gif",
  "description": "Half-life of double trees. These are initially two complementary trees which interact, doubling, randomly, while shortening in the same time. So in a sense is like a random decay. However, if the trees were really big, then it would look like a multiplication process, one double-tree creating two double-trees and so on. Of course, the more and more double-trees there are, the bigger is the competition on available enzymes, so the explosion is not exponential. Due to the fact that each double-tree has the same number of reaction patterns, it means that at each time there will be several generations of double-trees present. "}, 
{"title": "semtree.gif",
  "description": "I\u0027m a supporter of \"no semantics\" and I\u0027ll try to convince you that it is nothing vague in it.<br><br>Take any formalism. To any term built from this formalism there is an associated syntactic tree. Now, look at the syntactic tree and forget about the formalism. Because it is a tree, it means that no matter how you choose to decorate its leaves, you can progress from the leaves to the root by decorating each edge. At each node of the tree you follow a decoration rule which says: take the decorations of the input edges and use them to decorate the output edge. If you suppose that the formalism is one which uses operations of bounded arity then you can say the following thing: strictly by following rules of decoration which are local (you need to know only at most N edge decorations in order to decorate another edge) you can arrive to decorate all the tree. Al the graph! And the meaning of the graph has something to do with this decoration. Actually the formalism turns out to be not about graphs (trees), but about static decorations which appear at the root of the syntactic tree.<br>But, you see, these static decorations are global effects of local rules of decoration. Here enters the semantic police. Thou shall accept only trees whose roots accept decorations from a given language. Hard problems ensue, which are heavily loaded with semantics.<br>Now, let\u0027s pass from trees to other graphs.<br>The same phenomenon (there is a static global decoration emerged from local rules of decoration) for any DAG (directed acyclic graph). It is telling that people LOVE DAGs, so much so they go to the extreme of excluding from their thinking other graphs. These are the ones who put everything in a functional frame.<br>Nothing wrong with this!<br>Decorated graphs have a long tradition in mathematics, think for example at knot theory.<br>In knot theory the knot diagram is a graph (with 4-valent nodes) which surely is not acyclic! However, one of the fundamental objects associated to a knot is the algebraic object called \"quandle\", which is generated from the edges of the graph, with certain relations coming from the edges. It is of course a very hard, fully loaded semantically problem to try to identify the knot from the associated quandle.<br>The difference from the syntactic trees is that the graph does not admit a static global decoration, generically. That is why the associated algebraic object, the quandle, is generated by (and not equal to) the set of edges.<br><br>There are beautiful problems related to the global objects generated by local rules. They are also difficult, because of the global aspect. It is perhaps as difficult to find an algorithm which builds an isomorphism between two graphs which have the same associated family of decorations, as it is to find a decentralized algorithm for graph reduction of a distributed syntactic tree.<br><br>But these kind of problems do not cover all the interesting problems.<br><br>What if this global semantic point of view makes things harder than they really are?<br><br>Just suppose you are a genius who found such an algorithm, by amazing, mind bending mathematical insights.<br><br>Your brilliant algorithm, because it is an algorithm, can be executed by a Turing Machine.<br><br>Or Turing machines are purely local. The head of the machine has only local access to the tape, at any given moment (Forget about indirection, I\u0027ll come back to this in a moment.). The number of states of the machines is finite and the number of rules is finite.<br><br>This means that the brilliant work served to edit out the global from the problem!<br><br>If you are not content with TM, because of indirection, then look no further than to chemlambda (if you wish combined with TM, like in<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/turingchem.html\">link</a> , if you love TM ) which is definitely local and Turing universal. It works by the brilliant algorithm: do all the rewrites which you can do, nevermind the global meaning of those.<br><br>Oh, wait, what about a living cell, does it have a way to manage the semantics of the correct global chemical reactions networks which ARE the cell?<br><br>What about a brain, made of many neural cells, glia cells and whatnot? By the homunculus fallacy, it can\u0027t have static, external, globally selected functions and terms (aka semantic).<br><br>On the other side, of course that the researcher who studies the cell, or the brain, or the mathematician who finds the brilliant algorithm, they are all using heavy semantic machinery.<br><br>TO TELL THE STORY!<br><br>Not that the cell or the brain need the story in order for them to live.<br><br>In the animated gif there is a chemlambda molecule called the 28 quine, which satisfies the definition of life in the sense that it randomly replenish its atoms, by approximately keeping its global shape (thus it has a metabolism). It does this under the algorithm: do all rewrites you can do, but you can do a rewrite only if a random coin flip accepts it.<br><br>Most of the atoms of the molecule are related to operations (application and abstraction) from lambda calculus.<br><br>I modified a bit a script (sorry, not in the repo this one) so that whenever possible the edges of this graph which MAY be part of a syntactic tree of a lambda term turn to GOLD\u003c while the others are dark grey.<br><br>They mean nothing, there\u0027s no semantics, because for once the golden graphs are not DAGs, and because the computation consists into rewrites of graphs which don\u0027t preserve well the \"correct\" decorations before the rewrite.<br><br>There\u0027s no semantics, but there are still some interesting questions to explore, the main being: how life works?<br><br><br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/28_syn.html\">28_syn.html</a>"}, 
{"title": "short_bigpred_egg_experia.gif",
  "description": "Two swirls, experia version. Replay of Two swirls with the quiner_experia.<br><br>Two swirls<br><a href=\"collection.html#74\" onclick=\"location.hash = 74; StartingPost();\">show</a><br><br><br>There are 3 new demos with the experia version. And you can do things yourselves.<br><br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/lisfact_2_mod_experia.html\">lisfact_2_mod_experia.html</a><br><br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/times_only_experia.html\">times_only_experia.html</a><br><br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/fo_ackermann_2_2_experia.html\">fo_ackermann_2_2_experia.html</a><br><br>- do side: go to the active branch of the chemlambda repository<br>and follow the steps explained in<br><br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>then bash quiner_experia.sh<br><br>(or modify the parameters in quiner_experia.awk)."}, 
{"title": "shuffle.gif",
  "description": "Shuffle trick. Before: there are two pairs, each made of a blue and a red out ports. After the shuffle trick there is a pair of blue ports and a pair of red ports.<br><br>Before: there is a green node (FO fanout) and two pale yellow nodes (FOE fanouts).<br>After: there is one pale yellow node instead (FOE fanout) and two green nodes (FO fanouts)<br><br>This is achieved by an unstaged combination of two rewrites: FO-FOE and FI-FOE. It is unstaged because at the beginning only the pattern for FO-FOE exists, and after the FO-FOE rewrite appears the FI-FOE pattern.<br><br>During the shuffle trick the FO nodes migrate towards the leaves and the FOE nodes migrate towards the root.<br><br>This is how duplication of trees of fanouts is achieved in chemlambda.<br><br>See the shuffle trick live at:<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/shuffle_trick.html\">shuffle_trick.html</a><br><br>See the list of moves at:<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/moves.html\">link</a>"}, 
{"title": "spiral_boole_bb_short.gif",
  "description": "Turing machines grafted on the mock Ebola matrix constructor. Want to know more? Scroll down for the last posts and google chemlambda."}, 
{"title": "spiral_boole_circular_short.gif",
  "description": "Circular tubes, a version of [1].<br><br>[1] Tubes<br><a href=\"collection.html#211\" onclick=\"location.hash = 211; StartingPost();\">show</a>"}, 
{"title": "spiral_boole_construct2_orig_in.gif",
  "description": "The Replicant. This is a molecular machine designed as a patch which would upgrade biological ribosomes. Once it attaches to a ribosome, it behaves in an almost similar ways as the synthetic ribosome Ribo-T, recently announced in Nature 524,119–124(06 August 2015) doi:10.1038/nature14862 [1]. It thus enables an orthogonal genetic system, (i.e., citing from the mentioned Nature letter \"genetic systems that could be evolved for novel functions without interfering with native translation\").<br><br>The novel function is designed for is more ambitious than specialized new proteins synthesis. It is, instead, a two-ways translation device, between real chemistry and programmable artificial chemistry.<br><br>It behaves like a bootstrapper in computing. It is itself simulated in chemlambda, an artificial chemistry which was recently proposed as a means towards molecular computers [2]. The animation shows one of the first successful simulations.<br><br>With this molecular device in place, we can program living matter by using living cells themselves, instead of using, for example, complex, big 3D DNA printers like the ones developed by Craig Venter.<br><br>The only missing step, until recently, was the discovery of the basic translation of the building blocks of chemlambda into real chemistry.<br><br>I am very happy to make public a breakthrough result by Dr. Eldon Tyrell/Rosen, a genius who went out of academia some years ago and pursued a private career. It appears that he got interested early in this mix of lambda calculus, geometry and chemistry and he arrived to reproduce with real chemical ingredients two of the chemlambda graph rewrites: the beta rewrite and one of the DIST rewrites.<br><br>He tells me in a message that he is working on prototypes of replicants already.<br><br>He suggested the name \"replicant\" instead of a synthetic ribosome because a replicant, according to him, is a device which replicates a computer program (in chemlambda molecular form) into a form compatible with the cellular DNA machine, and conversely, it may convert certain (RNA) strands into chemlambda molecules, i.e. back into synthetic form corresponding to a computer program.<br><br>[1] Protein synthesis by ribosomes with tethered subunits, C. Orelle, E. D. Carlson, T. Szal, T. Florin, M. C. Jewett, A. S. Mankin<br><a href=\"https://www.nature.com/nature/journal/v524/n7563/full/nature14862.html\">link</a><br><br>[2] Molecular computers, M Buliga<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/molecular.html\">link</a>, <a href=\"https://arxiv.org/abs/1811.04960\">arXiv:1811.04960</a><br><br>[This post is a reply to +Yonatan Zunger post<br>[not available]<br>where he shows that the INCEPT DATE of the Blade Runner replicant Roy Batty appears to be 8 Jan, 2016.<br>So here is a replicant, in the inception phase :) ]"}, 
{"title": "spiral_boole_construct2_origX2_short.gif",
  "description": "Morphing (spiral matrices constructors in parallel). This is the first third of a longer simulation, which uses a hibridization of two spiral matrices constructors. It goes like this: 4min run of the scripts which build the simulation, 2h30min of filming the simulation until the computer crashes at about 2/3 of it. The crash is due to optimizations, automatic, semantic based optimizations.<br><br>Btw, when I come again and again to mention the lack of (global) semantics, it does not mean that I\u0027m not capable to find an overarching one, it means that it is a consequence of the formalism that there can\u0027t be one. Like in nature. Do you like nature? Kind of agree with Jack London? There, you see?"}, 
{"title": "spiral_boole_construct_2_series_parallel.gif",
  "description": "Tube constructors in series and in parallel. Complex shapes obtained with no control or synchronization, these two chained animations are an addition to the tube constructors series (dec 2015 - jan 2016) started with the mock ebola matrix animation."}, 
{"title": "spiral_boole_construct_test_deterministic.gif",
  "description": "Competing chemical transactions and emergence of chemlisps.<br>By definition a transaction is either a rewrite from the list of accepted rewrites (say of chemlambda) or a composition of two transaction which match. A transaction has a left and a right pattern and a proof (which is the transaction expressed as a cascade of accepted rewrites).<br><br>When you reduce a molecule, the output is a proof of a transaction. The transaction proof itself is more important than the molecule from the start. Indeed, if you think that the transaction proof looks like a list:<br><br>rm leftpattern1<br>add rightpattern1<br>…<br><br>where leftpattern1 is a list of lines of a mol file, same for the rightpattern1, then you can deduce from the transaction proof only the following:<br><br>– the minimal initial molecule needed to apply this transaction, call it the left pattern of the transaction<br>– the minimal final molecule appearing after the transaction, call it the right pattern of the transaction<br><br>Therefore any transaction has:<br>– a left pattern<br>– a right pattern<br>– a proof made of a chain of other transactions which match (the right<br>pattern of transaction N contains the left pattern of transaction N+1)<br><br>It would be useful to think in term of transactions and their proofs<br>as the basic objects, not molecules. (source: [1])<br><br>There is much more about these chemical transactions and their proofs.<br><br>First is that transactions are partially independent on the molecules.<br><br>The blockchain may be useful only for having a distributed database of transactions and proofs, available for further use. But there's more.<br><br>Think about this database as one of valid computations, which can then be reused in any combination or degree of parallelism. Then, that's the field of several competitions.<br><br>The same transaction can have several proofs, shorter or longer. It can have big left pattern therefore costly to use it in another computation. Maybe a transaction goes too long and therefore it is not useful to use in combination with others.<br><br>When there is a molecule to reduce, the application of a transaction means:<br>– identify a subgraph isomorphic with the left pattern and pick one such subgraph<br>– apply the transaction to this particular subgraph (which is equivalent with: reduce only that subgraph of the molecule, and freeze the rest of the molecule, but do it in one step because the sequence of reductions is already pre-computed)<br><br>Now, which is more convenient, to reduce the molecule by using the random algorithm and the available graph rewrites, or to use some transactions which fit, which is fast (as concerns step 2) but costly (as concerns step 1), moreover it may be that there is a transaction with shorter proof for that particular molecule, which mixes parts of several available precomputed transactions.<br><br>Therefore the addition of transactions and their proofs (needed to be able to validate them) into the database should be made in such a way which profit from this competition.<br><br>If I see the reduction of a molecule (which may be itself distributed) as a service then besides the competition for making available the most useful transactions with the shortest proofs, there is another competition between brute force reducing it and using the available transactions, with all the time costs they need.<br><br>If well designed, these competitions should lead to the emergence of clusters of useful transactions (call such a cluster a \"chemlisp\" ) and also to the emergence of better strategies for reducing molecules.<br><br>This will lead to more and more complex computations which are feasible with this system and probably fast enough they will become very hard to understand by a human mind, or even by using IT tools on a limited part of the users of the system. (source: [2])<br><br>That\u0027s a reason why I like the effort to build a Haskell API for chemlambda [3].<br><br>About the picture: I used the test scripts (done for easing the comparison with chemlambda-hask [3]), exactly as described in the post [4].<br><br>Have you noticed that the output of the chemlambda scripts are basically chemical transactions, as described here? They are, just look inside the html output, after the html and d3.js necessary stuff, all there is a list of add, remove, ... a transaction.<br><br>I modified just a bit the output to make this more visible.<br><br>The molecule used is spiral_boole_construct.mol, available at the library of chemlambda molecules, which is nothing other than the mock Ebola matrix constructor molecule (i.e. it builds the matrix starting from a small pattern). Remember the first mock Ebola matrix post [5]? It was a very good post for making clear that chemlambda molecules are not flow diagrams, in contradistinction to all other graphs used as a sort of visual help in CS. Because what flow diagram is a virus matrix? Nonsense.<br><br><br>[1] Chemical transactions and their proofs<br><a href=\"https://chorasimilarity.wordpress.com/2016/08/20/chemical-transactions-and-their-proofs/\">link</a><br><br>[2] More about chemical transactions<br><a href=\"https://chorasimilarity.wordpress.com/2016/08/23/more-about-chemical-transactions/\">link</a><br><br>[3] chemlambda-hask<br><a href=\"https://github.com/synergistics/chemlambda-hask\">link</a><br><br>[4] Fractal out of the box<br>[not available]<br><br>[5] Mock Ebola matrix<br><a href=\"collection.html#213\" onclick=\"location.hash = 213; StartingPost();\">show</a>"}, 
{"title": "spiral_boole_construct.gif",
  "description": "Making, then unmaking (tube constructor). A tube is built, then is taken apart. For this we need a tube constructor molecule.<br>Thanks everybody for following this collection. Wish you the best, happy new year!"}, 
{"title": "spiral_boole_short.gif",
  "description": "Tubes. With a structure close to the one from the last post, this tubular molecule splits into two copies. The red nodes form pairs which encode booleans, lambda calculus style."}, 
{"title": "spiral_fibo_block_2_short.gif",
  "description": "Fibonacci numbers with tube constructors. That\u0027s what happens when I use the tube constructor molecule (from the previous posts) instead of the successor molecule, in the computation of Fibonacci numbers. What I did was to replace the succ with the tube constructor (as well as the initial condition) in the fibo_block_2.mol molecule from the repository. You can see a relative of the fibo molecule, and some explanations) at the demo <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/fibo.html\">fibo.html</a><br><br>The phenomenon here is that the tube constructor molecule does not behave exactly (from a functional pov) as the successor, therefore the result is not two tubes, one with 5 turns and the other with 8 turns. The central part of the molecule does not get to be activated. But I know what to do in order to make this happen. Next time."}, 
{"title": "spiral_short_with_picture.gif",
  "description": "Mock Ebola matrix. I took inspiration from +Alessandro Littara post [1] which presents an award winning molecule of the month, this time of the Ebola virus. In chemlambda, I made a molecule which has roughly the same symmetry, without the RNA content. It is a spiral repeating pattern.<br><br>I have no claim to make about the functionality of the molecule. First of all I\u0027m not a chemist. But, the point I want to make is this: artificial chemistry can have very disturbing applications, especially if my hypothesis that chemlambda can be used to make molecular computers [2] turns out to be true.<br><br>There are very strong ethical implications, I don\u0027t know what to make with them.<br><br>Shortly put: if this variant of a molecular computer can be done then there are pros and cons. The pros come from the fact that such molecular computers are life like, not like silicon based architectures. The cons are that these molecular computers are life like.<br><br>My only conclusion is that once the box is open (and it is open because that\u0027s how open science works), then one has to start studying the implications of the stuff and integrate them as quick as possible into technical and ethical constructs.<br><br>[1] +Alessandro Littara Useful resources. Molecule of the Month Archive.<br>[not available]<br><br>[2] Molecular computers<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/molecular.html\">link</a>, <a href=\"https://arxiv.org/abs/1811.04960\">arXiv:1811.04960</a>"}, 
{"title": "spiral_spiral_construct_short.gif",
  "description": "Boot of a 7 cell tissue."}, 
{"title": "stree.gif",
  "description": "Aggressive growth obtained from a 6 nodes molecule called stree.mol, with minimal effects postprocessing, because some applications of chemlambda may be worrying, see [1].<br><br>This molecule is related to the S combinator applied to itself. It will be added to the library of chemlambda molecules [2], along with the more recent molecules, at the next update.<br><br>[1] Pharma meets the IoT<br>[not available]<br><br>[2] Library of chemlambda molecules<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "surface_256x.gif",
  "description": "Surface generation. From a tiny seed of 16 nodes grows this surface-like graph.<br>The seed is surface.mol<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/surface.mol\">surface.mol</a><br><br>I used quiner.sh with cycounter\u003d80 (the graph grows very fast, so cycounter\u003e100 gives very big results.<br><br>This is a 256X sped animation (which takes about 20 min) of the result."}, 
//{"title": "surface_5_13_quine_hyb_short.gif",
//  "description": "The shrimp thing appears from a hybridization of the star maker [1] with the surface generator [2].<br>Many mysteries await to be untangled in chemlambda, many creatures to come to life.<br><br>[1] claudia_starmaker<br><a href=\"collection.html#120\" onclick=\"location.hash = 120; StartingPost();\">show</a><br><br>[2] Warped lightcone, or nano-material fabric<br><a href=\"collection.html#142\" onclick=\"location.hash = 142; StartingPost();\">show</a>"}, 
{"title": "switcher.gif",
  "description": "There are O(10^2) artificial molecules in chemlambda which are made by 2 main nodes. Most of them have interesting behaviour, split between:<br>- Y-combinator like molecules (they are like guns in the Game of Life, only that they shoot pairs of application and fanout nodes)<br>- propagators, like the \"bit\" used in the previous post about a DNA kind of tape made of two backbones and those bits, which is duplicated<br><a href=\"collection.html#235\" onclick=\"location.hash = 235; StartingPost();\">show</a><br>- and switchers, which are 2 nodes molecules which pass through a node and take one or the other possible directions (because the nodes are trivalent), and they also change the node into another.<br><br>This kind of description is of course misleading, because the nodes are not gates and the 2-nodes molecules are not signals. But when the rewrites (chemical reactions) are chained into a fast cascade, the effect is that they look like they pass through gates.<br><br>In the following animation the 2 nodes molecule from the left goes down and changes the central node from green to red. This allows the 2 nodes molecule from the right to pass down and to change the central node from red to yellow."}, 
//{"title": "synt_bigpred_experia_short.gif",
//  "description": "Is this alive enough? This is the quiner experia version applied on top of the synthetic script, to the ouroboros walker.<br>It should make sense if you follow the chemlambda collection."}, 
{"title": "synthetic_20_quine_det.gif",
  "description": "Invisible puppeteer. That\u0027s an update of the \"Protein\" post from the chemlambda collection. There is now a new script in the chemlambda repository, called quineri (one final \"i\" letter added to quiner) which allows to use Arrow elements as separators between different substructures in a molecule.<br><br>This is used here, in the deterministic version, for the synthesis of the 20_quine.<br><br>First you see a set of free atoms (there are 20 of them) which are the nodes of the future 20 quine. There are also 4 cycles, one very small (looks like a pair of atoms) and 3 big. These are the representation of a permutation of 30 elements, which encodes the bonds of the 20 quine graph (yes, there are 30 bonds).<br><br>For reasons I shall explain in a future post, the permutation is implemented with FI and FOE nodes, not with A and L nodes as previously.<br><br>As in the \"Protein\" post, they all make one chemlambda molecule, but this time, due to the trick of the new quineri script, you can see the permutation which is like the backbone of the protein, because the bonds between the \"free\" atoms and the backbone permutation (sort of a secondary structure) are not depicted.<br><br>As a bonus, a bit like in a famous picture by Dali of an invisible Voltaire, we see that the (invisible) enzymes who do the rewrites are like an invisible puppeteer which assembles the 20 quine.<br><br>Once assembled, the quine gets a boring, repetitive, deterministic life.<br><br>Done with the script quineri.awk (called by bash quineri.sh) and with the mol file synthetic_20_quine.mol from the chemlambda repository.<br><br>You can use it as explained (for quiner) in the<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>Mind that since almost a year the active branch of the repository is<br><br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">this</a><br><br>and not the master branch. This is so obvious and consistent with all the links I gave that it\u0027s probably trivial. But who knows..."}, 
//{"title": "synthetic_bigpred_train_bw.gif",
//  "description": "Another microscope version from [1].<br><br>[1] Synthetic ouroboros, animation<br>[not available]"}, 
//{"title": "synthetic_bigpred_train.gif",
//  "description": "Synthetic ouroboros, animation. This is the GIF version of the movie [1].<br><br>[1] Synthetic ouroboros, the movie<br>[not available]"}, 
{"title": "synthetic_bigpred.gif",
  "description": "Synthetic stuff. Now there is a script which allows to synthetize any chemlambda molecule, like in the previous Invisible puppeteer post.<br>Look in the chemlambda repository, namely at the pair synthetic.sh and synthetic.awk from this branch of the repository (i.e. the active branch)<br><br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>In this animation you see the result of the \"synthetic\" bigpred.mol (which was the subject of the recent hacker news<br><br><a href=\"https://news.ycombinator.com/item?id\u003d9906623\">link</a> )<br><br>What I did:<br>- bash synthetic.sh and choose bigpred.mol<br>- the output is the file synt.mol<br>- bash quineri.sh and choose synt.mol (I had a random evolution, with cycounter\u003d150, time_val\u003d5 (for safari, but for chromium I choose time_val\u003d10 or even 20).<br>- the output is synt.html<br>- I opened synt.html with a text editor to change a bit some stuff: at lines 109-110 I choose a bigger window        var w \u003d 800,  h \u003d 800; and smaller charges and gravity (look for and modify to .charge(-10)<br>.gravity(.08) ).<br><br>Then I opened the synt.html with safari. (Also worked with chromium). It\u0027s a hard time for the browser because the initial graph has more than 1400 nodes (and the problem is not coming from setTimeout because, compared with other experiments, there are not as many, but it comes from an obscure problem of d3.js with prototypes; anyway this makes firefox lousy, which is a general trend at firefox, don\u0027 know why, chromium OK and safari great. I write this as a faithful user of firefox!).<br>In this case even the safari had to think a bit about life, philosophy, whatnot, before it started.<br><br>I made a screencast with Quicktime and then sped it up progressively to 16X, in order to be able to fit it into less than 20s.<br><br>Then I converted the .mov screencast to .gif and I proudly present it to you!<br><br>It worked!<br><br>Now that\u0027s a bit surprising, because, recall, what I do is to introduce lots of new nodes and bonds, approx 6X the initial ones, which separate the molecule which I want to synthetize into a list of nodes and a list of edges. The list of edges is transformed into a permutation.<br><br>Now during the evolution of the synt molecule, what happens is that the permutation is gradually applied (because if randomness) and it will mix with the evolution of the active pieces which start already to rewrite.<br><br>But it worked, despite the ugly presence of a T node, which is the one which sometimes may create problems due to such interferences if the molecule is not very well designed.<br><br>At the end I recall what I believe is the take away message, namely that the mol file format is a data structure which itself can be turned into a molecule."}, 
{"title": "tape_long_4653_2_deterministic.gif",
  "description": "Metabolism is failed replication, deterministic version. Metabolism and replication are two main properties of life. Based on chemlambda simulations like [1], [2], I advanced the idea that metabolism is a failed variant of replication. Usually people think the contrary, namely that a living creature first needs a metabolism, a randomly functioning mechanism for preserving the identity of the creature. Then, later, among these creatures with metabolism, some of them began to replicate themselves and conquered the world. It is a matter of scale though: a metabolism is an overarching name for a myriad of random chemical cascades. Looking closer to those, we see again and again phenomena which are almost replications.<br>So what can be noticed by playing with the artificial life of chemlambda? That if I take a molecule which replicates and I change it only slightly, then I can transform replication into something else. Instead of two molecules from the initial one, I get the initial molecule and another one which continues to enter in independent chemical reactions. It looks similar to protein synthesis from a DNA tape.<br><br>This simulation is obtained by using the deterministic test scripts from the chemlambda repository, instructions of use [3]. BTW the animation from there is the random version of this one.<br><br>The molecule used is tape_long_4653_2.mol which is available at the library of molecules [4].<br><br>This is the deterministic evolution of the molecule, compare with a random one from [1].<br><br>[1] Metabolism as failed replication<br><a href=\"collection.html#222\" onclick=\"location.hash = 222; StartingPost();\">show</a><br><br>[2] Metabolism is failed replication idea<br><a href=\"collection.html#94\" onclick=\"location.hash = 94; StartingPost();\">show</a><br><br>[3] Chemlambda repository and use instructions<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[4] Chemlambda library of molecules<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "tape_long_4653_2_space_short.gif",
  "description": "Metabolism is failed replication, with space constraints, just a glimpse from a longer simulation (because of attention span constraints :)). Continues from [1], the same molecule, random evolution.<br><br>[1] Metabolism is failed replication, deterministic version<br><a href=\"collection.html#220\" onclick=\"location.hash = 220; StartingPost();\">show</a>"}, 
{"title": "tape_long_4653_2.gif",
  "description": "Metabolism as failed replication. For example protein synthesis."}, 
{"title": "tape_long_5346_5346.gif",
  "description": "Duplicate OR duplicate and execute. A continuation of [1]. These are other two tapes than in the previous example, the first only duplicates, the second one duplicates and one copy executes (you can see the leftover of it too, differently from the previous example).<br><br>[1] Duplicate and execute<br><a href=\"collection.html#234\" onclick=\"location.hash = 234; StartingPost();\">show</a>"}, 
{"title": "tape_long_5346_free_fineuron_short.gif",
  "description": "Birth certificate. I tried a second version of a polyribosome, see the first version [1]. The idea was to use the \"outputs\", i.e. the structures assembled from the initial tape as \"inputs\" of a older molecule called fineuron.mol. That old molecule is a sort of assembler which is switched off after it builds a short-lived quine which dies and blocks it.<br><br>I also used one of the tapes which suffers a faulty replication, appearing in previous posts about \"metabolism as failed replication\".<br><br>That\u0027s wanting too much. Looking for the trouble, right?<br><br>OK, somebody should give a birth certificate to this.<br><br>[1] Polyribosome, first attempt<br><a href=\"collection.html#225\" onclick=\"location.hash = 225; StartingPost();\">show</a>"}, 
{"title": "tape_long_5346_free_FO.gif",
  "description": "Polyribosome, first attempt in chemlambda. With space constraints, adapted from a tape (see the name of the gif when you try to save it, molecule not yet available at the library). Last post about polyribosomes [1].<br><br>[1] Polyribosomes as molecular 3D nanoprinters and vaults<br>[unavailable]"}, 
{"title": "tape_long_5364_bi_1.gif",
  "description": "Duplication of duplication. A DNA like tape duplicates in a very biological way, then the daughter tapes duplicate again! You may notice the processes which separate the copies."}, 
{"title": "tape_long_5364_bi_2_space_short.gif",
  "description": "Life snapshots, another in the series \"metabolism is failed replication\", with space constraints.<br>UPDATE: this is a screencast of a simulation, nothing else, i.e. no hidden director was involved. I did only two things after I computed the simulation: (1) opened safari and a screenshot window, which I moved a bit towards the end in order to keep the molecule more or less centered in the window (2) sped the movie obtained and transformed it into a gif."}, 
{"title": "tape_long_5364_bi_2.gif",
  "description": "A cell with 4 parents. Alien reproduction."}, 
{"title": "tape_long_5364_bi_3_v2.gif",
  "description": "The loop is the seed. Another play with tapes, compare with [1]. All activity is generated by the initial loop/tape. This time you can see the new nodes brighter than the older ones, so the activity sites are clearly visible.<br><br>[1] this animation uses the same initial molecule as the one from<br><a href=\"collection.html#228\" onclick=\"location.hash = 228; StartingPost();\">show</a><br><br>I did another run with this molecule and after that I just activated some delays and transitions in the d3.js output and changed the color of the bonds, the gravity and charge."}, 
{"title": "tape_long_5364_synt.gif",
  "description": "Synthetic replication. As a reply to the last post, this is a successful replication, there are only two bonds different wrt an (apparently) unsuccessful one. To spice things up, the replicant is first synthetized from a list (i.e. using the script synthetic.sh applied to the molecule) and then it works as designed. All this passage from the bigger version to the synthetized one is a process of elimination of non-geometric labellings and orderings a computer has to have by design (not by intrinsic need)."}, 
{"title": "tape_long_5364X25346_space.gif",
  "description": "Infected tape duplication with space constraints."}, 
{"title": "tape_long_5364X2_shuffle_deterministic_s.gif",
  "description": "Meiosis, first attempt, deterministic version. Done with an older script (moving_random_metabo.sh) which was set on deterministic. Compare with the last, random version [1].<br><br>[1] Meiosis, first attempt<br>[unavailable]"},
//<a href=\"collection.html#232\" onclick=\"location.hash = 232; StartingPost();\">show</a>"}, 
{"title": "tape_long_5364X2_shuffle.gif",
  "description": "Meiosis, first attempt. That\u0027s a first attempt to model meiosis [1] in chemlambda. +Gideon Rosenblatt asked in a comment at the post [2] what about sexual reproduction vs cloning. One can understand this as meiosis vs mitosis.<br><br>Among the key differences are that during meiosis there are produced 4 copies, not 2, like in mitosis, and that there is a random shuffle of the reproducing content. (That is not all, but I concentrate on these two for the moment.) I can do this by exploiting the \"shuffle trick\" [3], which is a pattern formed by 3 fanout nodes (a FO and a FOE, mind that in chemlambda there are two types of fanout nodes) which is essential for purely local replication of lambda terms graphs.<br><br>The shuffle trick can be transformed into a random shuffle of two bonds by placing this pattern in a context where there are conflicts of rewrites. A conflict of rewrites happens where a node is part of two, overlapping, patterns. The reduction algorithm is random, therefore placing the shuffle trick pattern in places where there might appear conflicts of rewrites is something which achieves, partially, the goal.<br><br>The nice part is that the 3 fanout nodes from the shuffle trick pattern do lead to 4 copies, not 2.<br><br>In the animation, done with the molecule [4] from the library of chemlambda molecules, you see a 4 fold replication and a random shuffle, but, as happens with a Mobius strip which is cut at the middle, instead of obtaining several disconnected copies, I got a longer strip.<br><br><br>[1] Meiosis<br><a href=\"https://en.wikipedia.org/wiki/Meiosis\">wikipedia</a><br><br>[2] Metabolism is failed replication idea<br><a href=\"collection.html#94\" onclick=\"location.hash = 94; StartingPost();\">show</a><br><br>[3] The shuffle trick<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/shuffle_trick.html\">shuffle_trick.html</a><br><br>[4] molecule used:<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/tape_long_5364X2_shuffle.mol\">tape_long_5364X2_shuffle.mol</a>"}, 
{"title": "tape_long_6543.gif",
  "description": "Duplicate, then execute. This is a DNA-like circular tape, which is duplicated and then one of the copies is \"executed\", producing other, complex molecules.<br>This is crazy, because is a variation of replication of a circular tape with \"bits\" on it, but what is unexpected is the execution part."}, 
{"title": "tape.gif",
  "description": "Duplication of a DNA like structure in chemlambda. It looks like DNA in the sense that it is like a ladder with two backbones. The steps of the ladder are of two kinds, which can be taken as a sort of bits (values): there is a kind which is simply a bond between a red and a green node, each from a backbone, the other kind is a pair of two green nodes in between a red a green node.<br>In this (rather arbitrary) convention, this is like a tape with 10101010 message.<br>How is made:<br>- used tape.mol and quiner.sh<br>- instructions <a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>There is a demo with this subject here<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/tape.html\">tape.html</a><br><br>First time explained in<br><a href=\"https://chorasimilarity.wordpress.com/2014/10/07/dna-err-tape-replication-pictures/\">link</a>"}, 
{"title": "test_111_sss_cut.gif",
  "description": "Edit distance space for a quine. This is the path in the edit distance space for a random evolution of the 28_quine.mol. It has been made as the Ackermann example of path in the edit distance space [1]. Each node represents a state of the quine during evolution and there are blue bonds for states closer than 12 in the edit distance. The red path is the evolution in time, from one state to the next one. The space is more confined, is connected, there is a central big blob of states which represent say the \"healthy\" quine states. There are some smaller blobs which are visited by the evolution, but the quine comes back to the central blob. That is a manifestation of the metabolism.<br><br>[1] Ackermann walks through edit distance space<br>[unavailable]"}, 
{"title": "test-11_s.gif",
  "description": "Kinesin relative. This testing animation shows a relative of the kinesin you can see in [1], for example. This one \"walks\" on itself, so to say. It would be nice to see the ballet of rewriting enzymes, which are still invisible in these animations.<br><br>[1] Two ways microtubule<br><a href=\"collection.html#140\" onclick=\"location.hash = 140; StartingPost();\">show</a>"}, 
//{"title": "test-18_sss_cut.gif",
//  "description": "Compare quiner_shuffle with quiner_experia. The same initial collection of molecules [1], with the quiner_experia script, gives the evolution from this video [2]. This animation is obtained with quiner_shuffle, slightly modified so to allow only node-decreasing rewrites (FI-FOE, A-L) or only node-increasing rewrites (the DIST family), alternatively, in this animation in waves of 800 time steps.<br><br>The main difference is in the \"filaments\" which appear because the DIST are not immediately balanced by the A-L and FI-FOE.<br><br>[1] 5_16_quine_bubbles_hyb.mol<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/mol/5_16_quine_bubbles_hyb.mol\">5_16_quine_bubbles_hyb.mol</a><br><br>[2] Artificial life:replication<br><a href=\"https://vimeo.com/138611273\">vimeo</a>"}, 
//{"title": "test-30_sss_cut.gif",
//  "description": "Symmetry breaking, specialization, adaptation, where will this converge?"}, 
//{"title": "test-31_ss_cut.gif",
//  "description": "Symmetry breaking, specialization, adaptation, part 2. Continues from [1], this is a middle stage in the computation.<br><br>[1] Symmetry breaking, specialization, adaptation<br>[not available]"}, 
//{"title": "test-36.gif",
// "description": "Meiosis attempt, variation. This is the last stage of a very small variation of [1]. Deterministic version, I\u0027m curious if the random version will work better.<br><br>[1] Meiosis, first attempt, deterministic version<br>[not available]"}, 
//{"title": "test-5.gif",
//  "description": "Ghost needs a faster shell, pls"}, 
{"title": "test-86_s5.gif",
  "description": "Middle of a neural network computation, detail."}, 
//{"title": "test-93_cut.gif",
//  "description": "Sequencer. Working on it."}, 
{"title": "testing_chemlambda-hask.gif",
  "description": "First testing the chemlambda Haskell API with the Ackermann function :)<br><br><a href=\"https://github.com/synergistics/chemlambda-hask\">link</a>"}, 
{"title": "there-is-no-spoon_2042443_GIFSoup.com(1).gif",
  "description": "Neo just learned about untyped lambda beta calculus. Heck, there is no function, he thinks."}, 
{"title": "times_only_64x.gif",
  "description": "Fast speed structure. This is another 64X speed screencast of an animation in chemlambda. It is a multiplication of two numbers (encoded as Church numbers, then transformed into chemlambda molecules).<br>As in the previous case [1], all details are lost but large scale structure emerges.<br>We see that from a small initial molecule (which has to contain all the ingredients for the computation) there are 3 stages:<br>- 1. there is a tree-like structure with bags of atoms as leaves, which grows fast from the initial molecule; this corresponds to the replication of numbers in a quantity which is sufficient further<br>- 2. in lambda calculus (so probably in a sense in chemlambda as well) multiplication is iterated addition and addition is iterated application of successor. This is what happens in this stage, but with a twist: because there are so many rewrites in the same time, asynchronously, the iterations mix and spread all over (n space, i.e. in the molecule as a graph, and in time). There is something which happens quich, we can\u0027t see it in this 64X sped animation, but the \"bags\" are consumed and displaced by a creature in the middle of the computation. I call this creature the numberphile microbe (a glimpse in [2]) and I intend to understand it, as I did with the walker which led to the notion of a chemlambda quine [3].<br>-3. when all but the last bag are consumed the creature dies and the computation ends by appending the content of the last bag to the loop which represents the result of the multiplication, again as a Church number.<br><br><br>The multiplication appears as a part in the computation of the factorial [4].<br><br>This was done with the script quiner.awk and the mol file times_only.mol from the chemlambda repository.<br><br>See the readme for instructions about how to use it:<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[1] Meaning, time dependent<br><a href=\"collection.html#53\" onclick=\"location.hash = 53; StartingPost();\">show</a><br><br>[2] The numberphile microbe<br><a href=\"https://chemlambda.wordpress.com/2015/02/18/numberphile-microbe/\">link</a><br><br>[3] The story of the first artificial life organism in chemlambda<br><a href=\"collection.html#196\" onclick=\"location.hash = 196; StartingPost();\">show</a><br><br>[4] The working factorial demo<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/lisfact_2_mod.html\">lisfact_2_mod.html</a>"}, 
{"title": "times_only_bb_short_opt.gif",
  "description": "Local machines can coexist. Here, in the upper side of the animation there is a chemlambda molecule derived from a lambda term. In the lower part of the figure there is a Turing machine. They work together, in harmony :)<br><br>Side argument for the post<br>[unavailable]"}, 
{"title": "times_only_space.gif",
  "description": "How it works. What you see is literary a multiplication. An arithmetic multiplication embodied by some chemical reactions (the molecule used is times_only.mol from the library of chemlambda molecules, you see here only a part of it\u0027s evolution). It does not matter though what it means, more interesting is how it works.<br><br>Imagine that you have to make it work without control and randomly.<br><br>Having flows of information through some decision gates does not work like that. If you opt for the flow-through-decision-gates idea then it does not scale enough, unless there is somewhere a centralization and a hidden director. The most you can have is the \"cloud\", that 10 years old idea that (if you are rich enough) then you can buy enough computers, make farms of computers and sell computer time on your farms to many people so they think they are doing independent work. With the benefit that you can watch over what happens in your computers farm, censor here a bit, enhance there a little, influence everybody to stay on the right tracks.<br><br>No, it can\u0027t work like this, is an old idea and it might lead to truly horrendous control, better than in any dream. For example you may try to micro-manage everybody by channeling their efforts towards real but not too disruptive goals, to make easy for them to talk with like minded people and not letting them see other, controversial for them, views.<br><br>Nature does not work like this. Cloud computing is the dinosaurs way: bigger is better, more centralized is better.<br><br>There is another possibility, to make it work in space. Create the patterns in space, let them change randomly and locally and, most important, let them create new patterns instead of the old. Eventually all patterns which are present will be modified, no matter by whom, nor when.<br><br>It is as simple as that, only that it surely does not work for any choice of basic chemical reactions. There are some, very few in the sea of possible ones, which do the job, while there are many which don\u0027t.<br><br>One of those which does the job is chemlambda."}, 
{"title": "toorings_8x.gif",
  "description": "Signal transduction. These are two rings united by a Holliday junction, or in the language used in chemlambda, they are hybridized.<br>Then, on each ring, forms and starts to propagate a \"signal\" which you can visualize as something jumpy which contains many red nodes.<br><br>There are two phenomena here:<br>- the \"signals\" propagate around the rings and each of them completes the tour and then disappears,<br>- at some point they have to pass through the junction, they mix and they separate, leaving the junction and the rings topology unchanged.<br><br>Let\u0027s analyze what happens.<br><br>1. The \"signals\" are in our eyes, from the point of view of the artificial chemistry chemlambda, there is only one big graph (molecule) which suffers random rewrites. The rings and the signals on them are entities which we see, but there is nothing in the rewriting algorithm which makes a distinction between \"signals\" and \"rings\".<br><br>2. As you see, the two signals don\u0027t arrive at the same time at the end of their tours. That is because the rewrites are random, and it just happens like that. For another run of the algorithm, the timing may be different. There is nothing in the algorithm which manages the timing of \"signals\".<br><br>3. The \"signals\" appear and then they spread along the rings, they mix, they propagate and then they disappear. The size of the spreading depends on the particular run of the algorithm, there is nothing which decides how big is the size of the \"signal\".<br><br>4. Nobody manages the junction where the \"signals\" meet. The junction looks like a gate with two inputs and two outputs, which takes the \"signals\" and output them crosswise.<br><br>5. The signals are propagating via cascades of chemical reactions (rewrites). Seen from the plane, it looks like there is really a signal sent through a wire (the ring), going through gates, but this impression is only a story which we create in our mind.<br><br>This is the story which is so familiar in IT: there are wires, signals, senders and receivers. The wires are used to connect gates. Signals represent variables and gates are functions with inputs and outputs.<br><br>In signal transduction story<br><a href=\"https://en.wikipedia.org/wiki/Signal_transduction\">wikipedia</a><br>there is a \"signal\" (an illusion of the storyteller, of course) which propagates via a cascade of chemical reaction (correct view).<br><br>At least half of the story is realistic in signal transduction!<br><br>Why is this interesting for IT?<br><br>Because once you have signals and gates and functions, then you have to manage them. The whole story of evaluation is about managing signals and gates. What to do first? replace this value in this term, or wait until I really need it, or duplicate a value, or in the case of quantum computing do otherwise because there is a theorem which tells me that I don\u0027t have the luxury to replicate values?<br><br>The story of signals, gates and function is in the programmer (or engineer) mind. Nature has a way, different. Chemlambda has it too, which proves that we can understand Nature\u0027s way.<br><br>Validation. This is a 8x sped animation of the result given by quiner.sh applied to the mol file toorings.mol.<br>You can see a different result at<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/toorings.html\">toorings.html</a><br>You can make your own by following the instructions<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "topocut.gif",
  "description": "newfact_zero demo. <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/newfact_zero.html\">newfact_zero.html</a>"}, 
{"title": "torus_pwheel_8_compo_mola.gif",
  "description": "Containment and diffusion. Think about the yellow part as being a membrane which contains the internal part in red. A good membrane should allow containment and diffusion.<br><br>As membranes and interiors are of semantic nature, I use actor colors for those.<br><br>This is a hybridisation of a permutation quine [1] with a torus quine [2]. I used actor colors and colored rewrites (i.e. the quiner_node script), with the red color for the permutation quine and the yellow color for the torus quine.<br><br>The permutation quine has period 8 (in the deterministic algorithm) and the torus quine has period 4. This allows for a very big variety of configuration of the hybrid in the random algorithm.<br><br><br>[1] Permutation wheel<br><a href=\"collection.html#192\" onclick=\"location.hash = 192; StartingPost();\">show</a><br><br>[2] Torus quine<br>[unavailable]"}, 
//{"title": "torus_short_opt.gif",
//  "description": "Torus quine. Initially a torus, then it evolves to something to be submitted to the X Files :)<br>Done with quiner experia, this time the nodes are visually privileged. 64X sped screencast."}, 
{"title": "ttttt.gif",
  "description": "5!\u003d120 chemlambda style."}, 
{"title": "tubefact_large_short.gif",
  "description": "Molecular blog (big factorial). Technically, what you see is a big factorial computation, chemlambda version. It is an improved version of [1] (and see also [2] for an earlier simulation, of another molecule inspired by the factorial). OK, how can this be related to a memory? Very simple!<br><br>This really is a molecular program, the same as the one from the simulations related to the mock ebola matrix building, like [3], but which is loaded with another iteration, one which gives, eventually, a sort of 2 dimensional sheet of a molecule.<br><br>It can be adapted so that one could write on this sheet. Not a human, nor a computer, but why not a living cell?<br><br>By interacting with the iterated builder, it could be turned into a chemical web log of the very fast and complex cascades which are the life of the cell.<br><br>It would be much more dense than a 1 dimensional record, thus perhaps beating blind nature evolution solution.<br><br>It can be easily read by a reversal of the writing (building) which corresponds in the Hylaean Theorical World (yes I like +Neal Stephenson ) to the operation of application to some lambda term.<br><br>[1] Factorial wheel<br><a href=\"collection.html#249\" onclick=\"location.hash = 249; StartingPost();\">show</a><br><br>[2] A small part of a bigger factorial computation<br><a href=\"collection.html#144\" onclick=\"location.hash = 144; StartingPost();\">show</a><br><br>[3] Making, then unmaking<br><a href=\"collection.html#210\" onclick=\"location.hash = 210; StartingPost();\">show</a>"}, 
//{"title": "tubefact_large_tangled.gif",
//  "description": "Tangled factorial, back and forth. While exploring variations of the memory sheet formation, from the last post, I found useful to be able to play also with time."}, 
//{"title": "tubefact_string.gif",
//  "description": "Strings visualization attempt New soft is needed, but something can be done with the one available. This is a simulation of the molecule tubefact.mol with tweaked visualization, in order to make the chemlambda strings more visible. See the working version of the article [1] for the context.<br><br>[1] Chemlambda strings <br><a href=\"http://imar.ro/~mbuliga/chemlambda_strains.html\">link</a>"}, 
{"title": "tubefact.gif",
  "description": "Factorial wheel. In the tube constructor, I replaced the pattern from the Ebola matrix by one which corresponds to the function (a,b) \\mapsto (a+1, ab). When applying the number 5 to the constructor, I get 6 (that\u0027s the \"tail\" you see at the end) and a nice wheel with 5!\u003d120 green nodes."}, 
{"title": "tubefact_X3_short.gif",
  "description": "Mix of 3 programs disentangle and proceed at own\u0027s pace. Imagine 3 instances of the same program which you want to run in the same time. Now, mix the programs instructions by pointing some intermediary outputs of one program to the corresponding intermediary inputs of another. Then execute them in the same time without any control unit or counter unit.<br><br>Initial computing machines were running much less ambitious programs."}, 
//{"title": "tubefibo_big.gif",
//  "description": "Pseudoknot evolving."}, 
{"title": "tubefibo_large_dode_micro_2.gif",
  "description": "Microscope views. These images say all about the proposal to use chemlambda to build molecular computers, or to recognize molecular computers in nature. These are very far from the usual tentative to mimic silicon computers in vivo."}, 
//{"title": "tubefibo_large_mny_more.gif",
//  "description": "Autonomous data management. You see a key stage in a computation which is the chemical version of a neuron. It is unstaged. I want to release all the sources of the animations I\u0027ve made and put in this collection. This means the molecules (in the form of mol files) and many of the simulations themselves (these simulation files have about 750 MB). If anybody is interested into having them and instructions about how to play with them then please send a me a mail."}, 
{"title": "tubefibo_large.gif",
  "description": "Structure of a thought. I\u0027m amazed by the vagueness, but I understand the wonder, of descriptions about what a recurrent network does. It\u0027s all guesses, clumsy mappings of words on bits running from here to there.<br>So, let\u0027s just forget about the network for a moment and let\u0027s follow the thought. What is the structure of a thought? Is obvious that backpropagation is a form of interaction with the future expectations of the network. There is no network, there are only cascade of locally meaningful parts, which flow, again, again and again, until they (arrive to a conclusion, network learns). (Usually this part is also in a nonsensical curried form.)<br>Forget about the network, because is just tubes and gates, look at the flow. Look at the power of random chemical cascades.<br>In this animation you see a very simple example of a visualization of a thought forming in such a network. Later on (of course if this network will show signs it\u0027s not already dead) I\u0027ll come with details."}, 
{"title": "turing_loop.gif",
  "description": "Local machines can coexist II. Turing loops. A better short movie about Turing machines combined with chemlambda, as explained in [1], first animation appeared in [2]. Was prepared to be included in a talk, this is a cheap animated gif version.<br><br>[1] Church numbers applied to busy beavers js demo<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/random_church.html\">random_church.html</a><br><br>[2] Local machines can coexist<br><a href=\"collection.html#242\" onclick=\"location.hash = 242; StartingPost();\">show</a>"}, 
{"title": "virus_bb.gif",
  "description": "Turing machines grafted on the mock Ebola matrix constructor II. Virus like envelope with Turing machines a better animation than [1], first posted in [2]. For TM in chemlambda see [3].<br><br>[1] Turing machines grafted on the mock ebola matrix constructor<br><a href=\"collection.html#204\" onclick=\"location.hash = 204; StartingPost();\">show</a><br><br>[2] [not available]<br><br>[3] Turing machines chemlambda style<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/turingchem.html\">link</a>"}, 
{"title": "walker_bit_new.gif",
  "description": "Feed the ouroboros (II). In the post [1] there is an animation which shows what happens with a walker, or ouroboros, which encounters something on its track: the thing gets eaten, then something else is left on the track. At the next passage the walker processes again the new thing, leaves another, and so on.<br><br>In this animation you see this process repeated, with a very short track, in order to magnify the effects: shorter track means more cycles.<br><br>[1] Feed the ouroboros<br><a href=\"collection.html#256\" onclick=\"location.hash = 256; StartingPost();\">show</a>"}, 
{"title": "walker_bit.gif",
  "description": "Feed the ouroboros. An ouroboros like in the post [1] is fed with a pair of nodes (they form a \"bit\"), like described in the post [2]. What happens?<br>The ouroboros, or the walker, I used both names, ingests the bit, processes it and leaves the result on the trail, continuing as if nothing happened.<br><br>Therefore the ouroboros can eat! And still preserve its shape after that.<br><br>Because the trail is closed, there is a second encounter with the processed bit. The ouroboros can eat this as well and it produces a more complex pattern on the trail.<br><br>In the animation you see 4 passes of the ouroboros. THe pattern left on the trail grows like a fractal.<br><br>Done with the mol file walker_bit.mol (compare it with bigpred_trail.mol to see that it differs only by the addition of two nodes, the bit) and quiner [3] with random reduction (all weights set to 1). I chose cycounter\u003d600 (i.e. 600 steps) but I filmed much less. Then I sped up the screencast until it fitted under 30s.<br><br>After that I trimmed it and used an online converter from mov to gif.<br><br>You can see this time a tiny bit of this speeding, at the beginning of the animated gif. I left it as it is because perhaps it gives a good impression: even if the ouroboros looks alive, it is only the visualisation of the result of a computation. Hm.<br><br>[1] Ouroboros, the first quine<br><a href=\"collection.html#76\" onclick=\"location.hash = 76; StartingPost();\">show</a><br><br>[2] Walker eating bits and a comment on the social side of research<br><a href=\"https://chorasimilarity.wordpress.com/2014/10/31/walker-eating-bits-and-a-comment-on-the-social-side-of-research/\">link</a><br><br>[3] Chemlambda repository<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "ybbfirst.gif",
  "description": "Mirror Mirror on the Wall, Who\u0027s the simplest model of computation of Them All?<br><br>This post continues the one about the Y combinator applied to a Busy Beaver TM<br><br><a href=\"collection.html#258\" onclick=\"location.hash = 258; StartingPost();\">show</a><br><br>At the beginning of this gif you see:<br>- at left a Busy Beaver tape (and head)<br>- at right a Y combinator molecule<br>which they interact and the rest of the computation is in the linked post.<br><br>This answers to the question: when put on the same footing (graph rewrite systems with a random application algorithm), the lambda calculus is much simpler than TM, not even taking into consideration indirection.<br>(See my long comment from the previous post for more details)."}, 
{"title": "ybb.gif",
  "description": "Apply the Y combinator to a busy beaver Turing machine. Results in many busy beavers on the same tape.<br><br>In the animation you see the end of the computation (explanations about how it is done at \"validation means\").<br><br>The whole video is 30s, I couldn\u0027t figure how to gif it into 15 s, in order to see clearly also the beginning of the computation, with the Y combinator and with the busy beaver tape.<br><br><a href=\"https://youtu.be/ZS_jesDpJRI\">youtube</a><br><br>In this post you see the Y combinator in chemlambda<br><a href=\"collection.html#259\" onclick=\"location.hash = 259; StartingPost();\">show</a><br><br>Turing machines (and in particular busy beavers) and their interaction with chemlambda in this post<br>[unavailable]<br><br>So, what\u0027s happening: the busy beaver tape interacts with the Y combinator and all transforms into a closed tape with the extremities connected to two ports of a fanout (FOE, yellow). The third port of the FOE is connected to the rest of the tape.<br><br>Continuously, the FOE node copies what\u0027s in the closed loop and adds it to the rest of the tape.<br>In the same time, all heads continue to run, wherever they are.<br>(Recall that in chemlambda the Turing machine head, as well as the moving instructions, are on the tape and that the TM instructions are replaced by graph rewrites, see the post about TM in chemlambda.)<br><br>Validation means: done with the mol file ybb.mol and with quiner.sh.<br>Go to the readme file to see how you can do it too:<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>It is a random run with cycounter\u003d70 (i.e. 70 steps).<br>I fiddled a bit with the output ybb.html, by using these parameters:<br>.charge(-40)<br>.gravity(.14)"}, 
{"title": "ycombi.gif",
  "description": "The Y combinator in chemlambda, explained.<br>How is the animation related to lambda calculus and where are the differences?<br><br>First, what you see in the animation.<br><br>At the right hand side there are two univalent nodes: magenta (a free output, or FROUT) and yellow (a free input, or FRIN).<br>They connect to a trivalent green node (application node A), and the 3rd bond of that A node connects to the chemlambda molecule which represents the Y combinator coming from lambda calculus.<br><br>The animation starts and there are some random rewrites which eventually transform this graph into an ever growing ladder of trivalent green (application A) and yellow (fanout FOE) nodes.<br><br>If you look closer then you see more. The ladder which appears has two extremities: at right, the extremity which connects to the magenta (FROUT) and the yellow (FRIN) univalent nodes.<br><br>The other extremity seems to float free and that\u0027s where the rewrites happen almost at the end of the animation.<br><br>At this other extremity there is a 2 nodes molecule (made of an A and a FOE nodes) which is the Y combinator as seen in chemlambda.<br><br>This 2-nodes molecule shoot (build) the steps of the ladder one by one. This never stops, btw.<br><br>Each step of the ladder is made by two nodes, A and FOE.<br><br>How is this consistent with lambda calculus and where are the differences?<br><br>The initial molecule which corresponds to the Y combinator as a lambda term is built from the syntactic tree of the Y combinator.<br><br>As a term, the Y combinator is this:<br><br>Lf.( (Lx.(f(xx))) (Lx.(f(xx))) )<br><br>But chemlambda has no variables, so there is a way to replace the x, f by ... nothing.<br><br>This is not surprising, for example de Bruijn notation<br><a href=\"https://en.wikipedia.org/wiki/De_Bruijn_notation\">wikipedia</a><br>eliminates variables names from lambda calculus. (On the other side, when a rewrite -- like beta reduction -- is done on a lambda term in de Bruijn notation, this is a process which is global, in the sense that there is no a priori bound on the dimension of the neighbourhood of the rewrite pattern which is modified. So de Bruijn notation gets rid of names for variables but transforms the beta reduction into a global rewrite. In chemlambda the beta rewrite is local, despite the fact that there are no variable names.)<br><br>There is a procedure which is inherited from the ancestor of chemlambda, called graphic lambda calculus (or GLC), see section 3 \"Conversion of lambda terms) in<br><a href=\"https://www.complex-systems.com/abstracts/v22_i04_a01.html\">link</a><br><br>The idea is that one adds to the syntactic tree of the term some inversed trees made of fanout nodes. This leads to the baggy image of the molecule associated to the lambda term.<br><br>In this algorithm, as used in chemlambda, there is freedom for the choice of the fanout nodes, be them FO or FOE (recall that FOE has been introduced in the actual version of chemlamdba).<br><br>If you look carefully then you see that the part of the molecule in the animation which represents exactly the Y combinator term starts with a red node (i.e. a lambda node, the one which corresponds to Lf. ... from the Y combinator term). You can also easily recognize the two (xx) parts as made of a pair FOE (yellow) and A (green) nodes. Actually instead of writing xx we put a fanout FOE whose two outputs are connected to the input of the A node.<br><br>OK, so now let\u0027s see what we have, from the point of view of lambda calculus.<br><br>We have the Y combinator applied to something which is left unspecified.<br><br>Say we have the term YB, where B is an arbitrary, unspecified other lambda term.<br><br>In lambda calculus the reductions which may happen are all beta reductions (and some fanouts made under the table):<br><br>The beta reduction is simple:<br><br>(Lf.C) B --\u003e C[f\u003dB]<br><br>where C[f\u003dB] means the lambda term where all instances of f are magically replaced by B.<br><br>Let\u0027s see for our YB:<br><br>YB \u003d (Lf.( (Lx.(f(xx))) (Lx.(f(xx))) ) ) B --\u003e<br><br>(Lx.(B(xx))) (Lx.(B(xx))) --\u003e<br><br>B ( (Lx.(B(xx))) (Lx.(B(xx))) ) --\u003e<br><br>B ( B ( (Lx.(B(xx))) (Lx.(B(xx))) ) ) ....<br><br>and that goes and goes and goes indefinitely, at least as long as there are no reductions involving the term B itself!<br><br>What we see in lambda calculus: after the first reduction step there is a part of the term which stays the same:<br><br>(Lx.(B(xx))) (Lx.(B(xx)))<br><br>and an ever increasing<br><br>B (B ( ...<br>ladder.<br><br>But if you look closer than you may say that the ladder is made by a fanout of B and an application operation.<br><br>This is like in chemlambda!<br><br>Only that the part which stays the same<br>(Lx.(B(xx))) (Lx.(B(xx)))<br>is made by two lambda operations, to mention only this.<br><br>This is unlike chemlambda!<br><br>And the reason is that the beta reduction from lambda calculus appears as the rewrite BETA (or A-L, other name), or otherwise the rewrite well known since Wadsworth and Lamping, but this rewrite can be done in chemlambda regardless of the result (graph) being \"correct\" (i.e. a lambda term) or not. On top of this, the other rewrites, which are essential for chemlambda, like the distributivity rewrites, the FAN-IN, act in the same time, randomly, so the overall result in this case is that the initial \"correct\" Y combinator molecule transforms into a 2-nodes molecule which is not the representation of a lambda term.<br><br>Indeed, it is made by an A (green) and a FOE (yellow). It can\u0027t be the molecule which represent<br>(Lx.(B(xx))) (Lx.(B(xx)))<br>because it would have to contain some L (red) nodes).<br><br>This animation has been done with the mol file y_combi.mol and with quiner.sh .<br><br>If you want play yourself then follow the instructions from here<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>If you want to refresh your image about the rewrites of chemlambda (in v2) then see the list here<br><a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/moves.html\">link</a><br><br>An older version of the behaviour of the Y combinator molecule, done in chemlambda v1 (without the FOE node and without some DIST moves)<br>is here<br><a href=\"http://imar.ro/~mbuliga/y_combinator.html\">link</a><br><br>This older version is explained in the article<br><a href=\"https://arxiv.org/abs/1403.8046\">arXiv:1403.8046</a><br><br>That is why I said repeatedly that there are 2-nodes molecules which are Y-combinator like.<br><br>And finally this 2-node molecule is used as axon in the post<br><br>Neural networks, Turing\u0027 B-type unorganised machine and artificial chemistry<br>[unavailable]<br><br>Because this Y-combinator like molecule does not stop, it has to be trapped in a quine, you see now? In the neuron post the quine is chosen to be one with a short life.<br><br>Everything is connected :)<br><br>_________________________________________"}, 
{"title": "yfromcomb_zip.gif",
  "description": "Zipped computation. First, because of the lossy compression and sped up animation, this has an unexpected cartoonish quality. But what is it? Be sure it is a random cascade of chemical reactions, which looks so \"mechanical\" and \"staged\" not because it is controlled in any way, but because the molecule it is created so that there is almost all the time only one active site for the next reaction.<br><br>I used a zipper for that. See the post [1] about zipper logic.<br><br>I took a relation from combinatory logic, which allows to express the Y combinator in the SKI formalism. (I used this relation in an older, live demo [2].) Then I wanted to compute YI, where Y is replaced by it\u0027s expression in SKI.<br><br>As a chemlambda molecule, this would look as a binary tree which has as leaves baggy molecules (for S, K, and I).<br><br>Now I want to zip it, so that it does not start to work in too much parallel ways (well, I like that it is possible to let it do many reductions, here and there in the same time of the global observer... don\u0027t let me start again about the fallacy of the global time observer).<br><br>So imagine this tree. I take a magic pen and start to draw a line which crosses any branch of the tree. The pen is magic because the line is actually a zipper! So I unzip it and every branch is now broken, half of it on one side, the other half on the other side of the opened zipper.<br><br>By random reductions, which have to happen in a fixed sequential way (because that\u0027s a zipper for), the zipper zips and gradually allows the tree to be rebuilt.<br><br>Then, when all is in place, the reduction (of the lambda calculus kind) begins and the YI becomes a growing worm, with a funny way of extending his head.<br><br>Because the Y combinator is a worm, recall? [3]<br><br><br><br>[1] <a href=\"collection.html#67\" onclick=\"location.hash = 67; StartingPost();\">show</a><br><br>[2] <a href=\"http://chorasimilarity.github.io/chemlambda-gui/dynamic/yfrcombtreefo.html\">yfrcombtreefo.html</a><br><br>[3] <a href=\"collection.html#259\" onclick=\"location.hash = 259; StartingPost();\">show</a>"}, 
{"title": "zpwheel_8_det_2.gif",
  "description": "Invention of the wheel done with the deterministic algorithm applied to the molecule zpwheel_8.mol available from the library of chemlambda molecules [1], see instructions to use [2].<br><br>[1] The library of chemlambda molecules<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a><br><br>[2] Instructions to use the library<br><a href=\"https://chorasimilarity.wordpress.com/2016/05/03/a-library-of-chemlambda-molecules/\">link</a>"}, 
{"title": "zpwheel_8_later.gif",
  "description": "The wheel, later. After some hundred more steps, this is how the wheel from [1] looks.<br>According to the color code, this is a deterministic evolution. As there has been a little reorganization in the repository, follow the instruction from [2] and the mol file zpwheel_8.mol.<br>I used the sh script from the test folder, which gives a list of mol files of the intermediate steps of the computation. With it I can have the mol file for the end result (after 50 steps), called tempo_50.mol, which I can copy to the mol folder and then call again the sh script, this time with the tempo_50.mol file. Repeat at will to go further.<br><br>[1] Invention of the wheel<br><a href=\"collection.html#261\" onclick=\"location.hash = 261; StartingPost();\">show</a><br><br>[2] Chemlambda-gui README<br><a href=\"https://github.com/chorasimilarity/chemlambda-gui/blob/gh-pages/dynamic/README.md\">readme</a>"}, 
{"title": "zz.gif",
  "description": "Pseudo-graphene builder made in chemlambda from a hybridization of the Z and Omega combinators."}];
